Disassembly Listing for hd_pov
Generated From:
/root/hd_pov/dist/default/production/hd_pov.production.elf
Jan 10, 2018 5:03:35 PM

---  /root/hd_pov/ringbufs..c  --------------------------------------------------------------------------
1:             
2:             #include  <string.h>
3:             #include  "ringbufs.h"
4:             
5:             /*
6:              * general ring buffer fuctions from the internet
7:              */
8:             uint8_t modulo_inc(const uint8_t value, const uint8_t modulus)
0C60  0100     MOVLB 0x0
0C62  6FB7     MOVWF value, BANKED
9:             {
10:            	uint8_t my_value = value + 1;
0C64  0100     MOVLB 0x0
0C66  29B7     INCF value, W, BANKED
0C68  6FB8     MOVWF c, BANKED
11:            	if (my_value >= modulus) {
0C6A  51B6     MOVF __pcstackBANK0, W, BANKED
0C6C  5DB8     SUBWF c, W, BANKED
0C6E  A0D8     BTFSS STATUS, 0, ACCESS
0C70  D002     BRA 0xC76
12:            		my_value = 0;
0C72  0E00     MOVLW 0x0
0C74  6FB8     MOVWF c, BANKED
13:            	}
14:            	return my_value;
0C76  51B8     MOVF c, W, BANKED
0C78  0012     RETURN 0
15:            }
16:            
17:            uint8_t modulo_inc_r(const uint8_t value, const uint8_t modulus)
0C7A  6E61     MOVWF value, ACCESS
18:            {
19:            	uint8_t my_value = value + 1;
0C7C  2861     INCF value, W, ACCESS
0C7E  6E62     MOVWF my_value, ACCESS
20:            	if (my_value >= modulus) {
0C80  5060     MOVF __pcstackCOMRAM, W, ACCESS
0C82  5C62     SUBWF my_value, W, ACCESS
0C84  A0D8     BTFSS STATUS, 0, ACCESS
0C86  D002     BRA 0xC8C
21:            		my_value = 0;
0C88  0E00     MOVLW 0x0
0C8A  6E62     MOVWF my_value, ACCESS
22:            	}
23:            	return my_value;
0C8C  5062     MOVF my_value, W, ACCESS
0C8E  0012     RETURN 0
24:            }
25:            
26:            void ringBufS_init(ringBufS_t *_this)
27:            {
28:            	/*****
29:            	  The following clears:
30:            	    -> buf
31:            	    -> head
32:            	    -> tail
33:            	    -> count
34:            	  and sets head = tail
35:            	 ***/
36:            	memset(_this, 0, sizeof(*_this));
0C06  C0BE     MOVFF _this, __pcstackBANK0
0C08  F0B6     NOP
0C0A  C0BF     MOVFF val, value
0C0C  F0B7     NOP
0C0E  0E00     MOVLW 0x0
0C10  0100     MOVLB 0x0
0C12  6FB9     MOVWF _this, BANKED
0C14  0E00     MOVLW 0x0
0C16  6FB8     MOVWF c, BANKED
0C18  0E00     MOVLW 0x0
0C1A  6FBB     MOVWF 0xBB, BANKED
0C1C  0E13     MOVLW 0x13
0C1E  6FBA     MOVWF n, BANKED
0C20  ECC2     CALL 0xB84, 0
0C22  F005     NOP
37:            }
0C24  0012     RETURN 0
38:            
39:            int8_t ringBufS_empty(ringBufS_t *_this)
40:            {
41:            	return(0 == _this->count);
0C44  0100     MOVLB 0x0
0C46  EE20     LFSR 2, 0x12
0C48  F012     NOP
0C4A  51B6     MOVF __pcstackBANK0, W, BANKED
0C4C  26D9     ADDWF FSR2, F, ACCESS
0C4E  51B7     MOVF value, W, BANKED
0C50  22DA     ADDWFC FSR2H, F, ACCESS
0C52  50DF     MOVF INDF2, W, ACCESS
0C54  A4D8     BTFSS STATUS, 2, ACCESS
0C56  D002     BRA 0xC5C
0C58  0E01     MOVLW 0x1
0C5A  0012     RETURN 0
0C5C  0E00     MOVLW 0x0
0C5E  0012     RETURN 0
42:            }
43:            
44:            int8_t ringBufS_full(ringBufS_t *_this)
45:            {
46:            	return(_this->count >= RBUF_SIZE);
0C26  0100     MOVLB 0x0
0C28  EE20     LFSR 2, 0x12
0C2A  F012     NOP
0C2C  51B6     MOVF __pcstackBANK0, W, BANKED
0C2E  26D9     ADDWF FSR2, F, ACCESS
0C30  51B7     MOVF value, W, BANKED
0C32  22DA     ADDWFC FSR2H, F, ACCESS
0C34  0E10     MOVLW 0x10
0C36  60DF     CPFSLT INDF2, ACCESS
0C38  D001     BRA 0xC3C
0C3A  D002     BRA 0xC40
0C3C  0E01     MOVLW 0x1
0C3E  0012     RETURN 0
0C40  0E00     MOVLW 0x0
0C42  0012     RETURN 0
47:            }
48:            
49:            uint8_t ringBufS_get(ringBufS_t *_this)
50:            {
51:            	uint8_t c;
52:            	if (_this->count > 0) {
08D2  0100     MOVLB 0x0
08D4  EE20     LFSR 2, 0x12
08D6  F012     NOP
08D8  51B9     MOVF _this, W, BANKED
08DA  26D9     ADDWF FSR2, F, ACCESS
08DC  51BA     MOVF n, W, BANKED
08DE  22DA     ADDWFC FSR2H, F, ACCESS
08E0  50DF     MOVF INDF2, W, ACCESS
08E2  B4D8     BTFSC STATUS, 2, ACCESS
08E4  D02D     BRA 0x940
53:            		c = _this->buf[_this->tail];
08E6  EE20     LFSR 2, 0x11
08E8  F011     NOP
08EA  51B9     MOVF _this, W, BANKED
08EC  26D9     ADDWF FSR2, F, ACCESS
08EE  51BA     MOVF n, W, BANKED
08F0  22DA     ADDWFC FSR2H, F, ACCESS
08F2  50DF     MOVF INDF2, W, ACCESS
08F4  6FBB     MOVWF 0xBB, BANKED
08F6  51BB     MOVF 0xBB, W, BANKED
08F8  0D01     MULLW 0x1
08FA  50F3     MOVF PROD, W, ACCESS
08FC  25B9     ADDWF _this, W, BANKED
08FE  6ED9     MOVWF FSR2, ACCESS
0900  50F4     MOVF PRODH, W, ACCESS
0902  21BA     ADDWFC n, W, BANKED
0904  6EDA     MOVWF FSR2H, ACCESS
0906  50DF     MOVF INDF2, W, ACCESS
0908  6FBC     MOVWF p, BANKED
54:            		_this->tail = modulo_inc(_this->tail, RBUF_SIZE);
090A  EE20     LFSR 2, 0x11
090C  F011     NOP
090E  51B9     MOVF _this, W, BANKED
0910  26D9     ADDWF FSR2, F, ACCESS
0912  51BA     MOVF n, W, BANKED
0914  22DA     ADDWFC FSR2H, F, ACCESS
0916  0E10     MOVLW 0x10
0918  6FB6     MOVWF __pcstackBANK0, BANKED
091A  EE10     LFSR 1, 0x11
091C  F011     NOP
091E  51B9     MOVF _this, W, BANKED
0920  26E1     ADDWF FSR1, F, ACCESS
0922  51BA     MOVF n, W, BANKED
0924  22E2     ADDWFC FSR1H, F, ACCESS
0926  50E7     MOVF INDF1, W, ACCESS
0928  EC30     CALL 0xC60, 0
092A  F006     NOP
092C  6EDF     MOVWF INDF2, ACCESS
55:            		--_this->count;
092E  0100     MOVLB 0x0
0930  EE20     LFSR 2, 0x12
0932  F012     NOP
0934  51B9     MOVF _this, W, BANKED
0936  26D9     ADDWF FSR2, F, ACCESS
0938  51BA     MOVF n, W, BANKED
093A  22DA     ADDWFC FSR2H, F, ACCESS
093C  06DF     DECF INDF2, F, ACCESS
56:            	} else {
093E  D002     BRA 0x944
57:            		c = 0; // return null with empty buffer
0940  0E00     MOVLW 0x0
0942  6FBC     MOVWF p, BANKED
58:            	}
59:            	return(c);
0944  51BC     MOVF p, W, BANKED
0946  0012     RETURN 0
60:            }
61:            
62:            void ringBufS_put(ringBufS_t *_this, const uint8_t c)
63:            {
64:            	if (_this->count < RBUF_SIZE) {
0948  EE20     LFSR 2, 0x12
094A  F012     NOP
094C  5063     MOVF _this, W, ACCESS
094E  26D9     ADDWF FSR2, F, ACCESS
0950  5064     MOVF 0x64, W, ACCESS
0952  22DA     ADDWFC FSR2H, F, ACCESS
0954  0E10     MOVLW 0x10
0956  60DF     CPFSLT INDF2, ACCESS
0958  0012     RETURN 0
65:            		_this->buf[_this->head] = c;
095A  EE20     LFSR 2, 0x10
095C  F010     NOP
095E  5063     MOVF _this, W, ACCESS
0960  26D9     ADDWF FSR2, F, ACCESS
0962  5064     MOVF 0x64, W, ACCESS
0964  22DA     ADDWFC FSR2H, F, ACCESS
0966  50DF     MOVF INDF2, W, ACCESS
0968  6E66     MOVWF 0x66, ACCESS
096A  5066     MOVF 0x66, W, ACCESS
096C  0D01     MULLW 0x1
096E  50F3     MOVF PROD, W, ACCESS
0970  2463     ADDWF _this, W, ACCESS
0972  6ED9     MOVWF FSR2, ACCESS
0974  50F4     MOVF PRODH, W, ACCESS
0976  2064     ADDWFC 0x64, W, ACCESS
0978  6EDA     MOVWF FSR2H, ACCESS
097A  C065     MOVFF c, INDF2
097C  FFDF     NOP
66:            		_this->head = modulo_inc_r(_this->head, RBUF_SIZE);
097E  EE20     LFSR 2, 0x10
0980  F010     NOP
0982  5063     MOVF _this, W, ACCESS
0984  26D9     ADDWF FSR2, F, ACCESS
0986  5064     MOVF 0x64, W, ACCESS
0988  22DA     ADDWFC FSR2H, F, ACCESS
098A  0E10     MOVLW 0x10
098C  6E60     MOVWF __pcstackCOMRAM, ACCESS
098E  EE10     LFSR 1, 0x10
0990  F010     NOP
0992  5063     MOVF _this, W, ACCESS
0994  26E1     ADDWF FSR1, F, ACCESS
0996  5064     MOVF 0x64, W, ACCESS
0998  22E2     ADDWFC FSR1H, F, ACCESS
099A  50E7     MOVF INDF1, W, ACCESS
099C  EC3D     CALL 0xC7A, 0
099E  F006     NOP
09A0  6EDF     MOVWF INDF2, ACCESS
67:            		++_this->count;
09A2  EE20     LFSR 2, 0x12
09A4  F012     NOP
09A6  5063     MOVF _this, W, ACCESS
09A8  26D9     ADDWF FSR2, F, ACCESS
09AA  5064     MOVF 0x64, W, ACCESS
09AC  22DA     ADDWFC FSR2H, F, ACCESS
09AE  2ADF     INCF INDF2, F, ACCESS
09B0  0012     RETURN 0
68:            	}
69:            }
70:            
71:            void ringBufS_flush(ringBufS_t *_this, const int8_t clearBuffer)
72:            {
73:            	_this->count = 0;
0A16  0100     MOVLB 0x0
0A18  EE20     LFSR 2, 0x12
0A1A  F012     NOP
0A1C  51BE     MOVF _this, W, BANKED
0A1E  26D9     ADDWF FSR2, F, ACCESS
0A20  51BF     MOVF val, W, BANKED
0A22  22DA     ADDWFC FSR2H, F, ACCESS
0A24  0E00     MOVLW 0x0
0A26  6EDF     MOVWF INDF2, ACCESS
74:            	_this->head = 0;
0A28  EE20     LFSR 2, 0x10
0A2A  F010     NOP
0A2C  51BE     MOVF _this, W, BANKED
0A2E  26D9     ADDWF FSR2, F, ACCESS
0A30  51BF     MOVF val, W, BANKED
0A32  22DA     ADDWFC FSR2H, F, ACCESS
0A34  0E00     MOVLW 0x0
0A36  6EDF     MOVWF INDF2, ACCESS
75:            	_this->tail = 0;
0A38  EE20     LFSR 2, 0x11
0A3A  F011     NOP
0A3C  51BE     MOVF _this, W, BANKED
0A3E  26D9     ADDWF FSR2, F, ACCESS
0A40  51BF     MOVF val, W, BANKED
0A42  22DA     ADDWFC FSR2H, F, ACCESS
0A44  0E00     MOVLW 0x0
0A46  6EDF     MOVWF INDF2, ACCESS
76:            	if (clearBuffer) {
0A48  51C0     MOVF clearBuffer, W, BANKED
0A4A  B4D8     BTFSC STATUS, 2, ACCESS
0A4C  0012     RETURN 0
77:            		memset(_this->buf, 0, sizeof(_this->buf));
0A4E  C0BE     MOVFF _this, __pcstackBANK0
0A50  F0B6     NOP
0A52  C0BF     MOVFF val, value
0A54  F0B7     NOP
0A56  0E00     MOVLW 0x0
0A58  6FB9     MOVWF _this, BANKED
0A5A  0E00     MOVLW 0x0
0A5C  6FB8     MOVWF c, BANKED
0A5E  0E00     MOVLW 0x0
0A60  6FBB     MOVWF 0xBB, BANKED
0A62  0E10     MOVLW 0x10
0A64  6FBA     MOVWF n, BANKED
0A66  ECC2     CALL 0xB84, 0
0A68  F005     NOP
0A6A  0012     RETURN 0
78:            	}
79:            }
---  /root/hd_pov/pat.c  --------------------------------------------------------------------------------
1:             // HD POV Version for XC8
2:             // PIC18F1320 Configuration Bit Settings 
3:             
4:             // CONFIG1H
5:             #pragma config OSC = HSPLL      // Oscillator Selection bits 40MHz fosc with PLL and 10MHz clock input
6:             #pragma config FSCM = ON        // Fail-Safe Clock Monitor Enable bit (Fail-Safe Clock Monitor enabled)
7:             #pragma config IESO = ON        // Internal External Switchover bit (Internal External Switchover mode enabled)
8:             
9:             // CONFIG2L
10:            #pragma config PWRT = OFF       // Power-up Timer Enable bit (PWRT disabled)
11:            #pragma config BOR = ON         // Brown-out Reset Enable bit (Brown-out Reset enabled)
12:            // BORV = No Setting
13:            
14:            // CONFIG2H
15:            #pragma config WDT = ON        // Watchdog Timer Enable bit 
16:            #pragma config WDTPS = 4096    // Watchdog Timer Postscale Select bits 
17:            
18:            // CONFIG3H
19:            #pragma config MCLRE = ON       // MCLR Pin Enable bit (MCLR pin enabled, RA5 input pin disabled)
20:            
21:            // CONFIG4L
22:            #pragma config STVR = ON        // Stack Full/Underflow Reset Enable bit (Stack full/underflow will cause Reset)
23:            #pragma config LVP = OFF        // Low-Voltage ICSP Enable bit (Low-Voltage ICSP disabled)
24:            
25:            // CONFIG5L
26:            #pragma config CP0 = ON        // Code Protection bit (Block 0 (00200-000FFFh) not code-protected)
27:            #pragma config CP1 = ON        // Code Protection bit (Block 1 (001000-001FFFh) not code-protected)
28:            
29:            // CONFIG5H
30:            #pragma config CPB = OFF        // Boot Block Code Protection bit (Boot Block (000000-0001FFh) not code-protected)
31:            #pragma config CPD = OFF        // Data EEPROM Code Protection bit (Data EEPROM not code-protected)
32:            
33:            // CONFIG6L
34:            #pragma config WRT0 = OFF       // Write Protection bit (Block 0 (00200-000FFFh) not write-protected)
35:            #pragma config WRT1 = OFF       // Write Protection bit (Block 1 (001000-001FFFh) not write-protected)
36:            
37:            // CONFIG6H
38:            #pragma config WRTC = OFF       // Configuration Register Write Protection bit (Configuration registers (300000-3000FFh) not write-protected)
39:            #pragma config WRTB = OFF       // Boot Block Write Protection bit (Boot Block (000000-0001FFh) not write-protected)
40:            #pragma config WRTD = OFF       // Data EEPROM Write Protection bit (Data EEPROM not write-protected)
41:            
42:            // CONFIG7L
43:            #pragma config EBTR0 = OFF      // Table Read Protection bit (Block 0 (00200-000FFFh) not protected from table reads executed in other blocks)
44:            #pragma config EBTR1 = OFF      // Table Read Protection bit (Block 1 (001000-001FFFh) not protected from table reads executed in other blocks)
45:            
46:            // CONFIG7H
47:            #pragma config EBTRB = OFF      // Boot Block Table Read Protection bit (Boot Block (000000-0001FFh) not protected from table reads executed in other blocks)
48:            
49:            
50:            /*
51:             * Driver for hard-drive strobe for POV demo
52:             * Versions
53:             * 1.0 RGB support
54:             * 1.1 multi sequence support
55:             * 1.2 cleanup state machine and data logic
56:             * 1.3 add routines for remote configuration of strobes
57:             * 1.4 add buffering for rs232
58:             */
59:            
60:            #include  <xc.h>
61:            #include <stdlib.h>
62:            #include <stdio.h>
63:            #include "pat.h"
64:            #include <string.h>
65:            #include "ringbufs.h"
66:            
67:            int16_t sw_work(void);
68:            void init_rmsmon(void);
69:            uint8_t init_rms_params(void);
70:            
71:            uint8_t str[24];
72:            near volatile struct L_data *L_ptr;
73:            near volatile struct V_data V = {0};
74:            uint16_t timer0_off = TIMEROFFSET, timer1_off = SAMPLEFREQ;
75:            near volatile struct L_data L[strobe_max] = {0};
76:            volatile uint8_t l_state = 2;
77:            volatile uint16_t l_full = strobe_limit_l, l_width = strobe_line, l_complete = strobe_complete;
78:            struct ringBufS_t ring_buf1;
79:            
80:            const uint8_t build_date[] = __DATE__, build_time[] = __TIME__;
81:            const uint8_t versions[] = "1.4";
82:            
83:            void interrupt high_priority tm_handler(void) // timer/serial functions are handled here
84:            {
85:            	if (INTCONbits.INT0IF) { // Hall effect index signal, start of rotation
0052  A2F2     BTFSS INTCON, 1, ACCESS
0054  D0AB     BRA 0x1AC
86:            		INTCONbits.INT0IF = FALSE;
0056  92F2     BCF INTCON, 1, ACCESS
87:            		RPMLED = (uint8_t)!RPMLED;
0058  BA8A     BTFSC LATB, 5, ACCESS
005A  D003     BRA 0x62
005C  6A67     CLRF 0x67, ACCESS
005E  2A67     INCF 0x67, F, ACCESS
0060  D001     BRA 0x64
0062  6A67     CLRF 0x67, ACCESS
0064  3A67     SWAPF 0x67, F, ACCESS
0066  4667     RLNCF 0x67, F, ACCESS
0068  508A     MOVF LATB, W, ACCESS
006A  1867     XORWF 0x67, W, ACCESS
006C  0BDF     ANDLW 0xDF
006E  1867     XORWF 0x67, W, ACCESS
0070  6E8A     MOVWF LATB, ACCESS
88:            		if (l_state == 1) { // off state too long for full rotation, hall signal while in state 1
0072  047D     DECF l_state, W, ACCESS
0074  A4D8     BTFSS STATUS, 2, ACCESS
0076  D004     BRA 0x80
89:            			l_full += strobe_adjust; // off state lower limit adjustments for smooth strobe rotation
0078  0E0B     MOVLW 0xB
007A  267B     ADDWF l_full, F, ACCESS
007C  0E00     MOVLW 0x0
007E  227C     ADDWFC 0x7C, F, ACCESS
90:            		}
91:            		l_state = 0; // restart lamp flashing sequence, off time
0080  0E00     MOVLW 0x0
0082  6E7D     MOVWF l_state, ACCESS
92:            
93:            		L_ptr = &L[V.line_num]; // select line strobe data
0084  3003     RRCF 0x3, W, ACCESS
0086  32E8     RRCF WREG, F, ACCESS
0088  0B03     ANDLW 0x3
008A  6E67     MOVWF 0x67, ACCESS
008C  5067     MOVF 0x67, W, ACCESS
008E  0D05     MULLW 0x5
0090  0E10     MOVLW 0x10
0092  24F3     ADDWF PROD, W, ACCESS
0094  6E0E     MOVWF L_ptr, ACCESS
0096  0E00     MOVLW 0x0
0098  20F4     ADDWFC PRODH, W, ACCESS
009A  6E0F     MOVWF 0xF, ACCESS
94:            		V.rotations++;
009C  4A06     INFSNZ 0x6, F, ACCESS
009E  2A07     INCF 0x7, F, ACCESS
95:            
96:            		/* limit rotational timer values during offsets */
97:            		switch (L_ptr->sequence.down) {
00A0  D056     BRA 0x14E
014E  C00E     MOVFF L_ptr, FSR2
0150  FFD9     NOP
0152  C00F     MOVFF 0xF, FSR2H
0154  FFDA     NOP
0156  A0DF     BTFSS INDF2, 0, ACCESS
0158  D002     BRA 0x15E
015A  0E01     MOVLW 0x1
015C  D001     BRA 0x160
015E  0E00     MOVLW 0x0
0160  0A00     XORLW 0x0
0162  B4D8     BTFSC STATUS, 2, ACCESS
0164  D79E     BRA 0xA2
0166  0A01     XORLW 0x1
0168  D7C7     BRA 0xF8
98:            		case 0:
99:            			L_ptr->strobe += L_ptr->sequence.offset;
00A2  EE20     LFSR 2, 0x1
00A4  F001     NOP
00A6  500E     MOVF L_ptr, W, ACCESS
00A8  26D9     ADDWF FSR2, F, ACCESS
00AA  500F     MOVF 0xF, W, ACCESS
00AC  22DA     ADDWFC FSR2H, F, ACCESS
00AE  CFDE     MOVFF POSTINC2, 0x67
00B0  F067     NOP
00B2  CFDD     MOVFF POSTDEC2, 0x68
00B4  F068     NOP
00B6  EE20     LFSR 2, 0x3
00B8  F003     NOP
00BA  500E     MOVF L_ptr, W, ACCESS
00BC  26D9     ADDWF FSR2, F, ACCESS
00BE  500F     MOVF 0xF, W, ACCESS
00C0  22DA     ADDWFC FSR2H, F, ACCESS
00C2  5067     MOVF 0x67, W, ACCESS
00C4  26DE     ADDWF POSTINC2, F, ACCESS
00C6  5068     MOVF 0x68, W, ACCESS
00C8  22DD     ADDWFC POSTDEC2, F, ACCESS
100:           			if (L_ptr->strobe < l_full)
00CA  EE20     LFSR 2, 0x3
00CC  F003     NOP
00CE  500E     MOVF L_ptr, W, ACCESS
00D0  26D9     ADDWF FSR2, F, ACCESS
00D2  500F     MOVF 0xF, W, ACCESS
00D4  22DA     ADDWFC FSR2H, F, ACCESS
00D6  507B     MOVF l_full, W, ACCESS
00D8  5CDE     SUBWF POSTINC2, W, ACCESS
00DA  507C     MOVF 0x7C, W, ACCESS
00DC  58DE     SUBWFB POSTINC2, W, ACCESS
00DE  B0D8     BTFSC STATUS, 0, ACCESS
00E0  D044     BRA 0x16A
101:           				L_ptr->strobe = l_full; // set to sliding lower limit
00E2  EE20     LFSR 2, 0x3
00E4  F003     NOP
00E6  500E     MOVF L_ptr, W, ACCESS
00E8  26D9     ADDWF FSR2, F, ACCESS
00EA  500F     MOVF 0xF, W, ACCESS
00EC  22DA     ADDWFC FSR2H, F, ACCESS
00EE  C07B     MOVFF l_full, POSTINC2
00F0  FFDE     NOP
00F2  C07C     MOVFF 0x7C, POSTDEC2
00F4  FFDD     NOP
102:           			break;
00F6  D039     BRA 0x16A
103:           		case 1:
104:           			L_ptr->strobe -= L_ptr->sequence.offset;
105:           			if (L_ptr->strobe < l_full)
106:           				L_ptr->strobe = strobe_limit_h;
107:           			break;
108:           
109:           		default:
110:           			L_ptr->strobe -= L_ptr->sequence.offset;
00F8  EE20     LFSR 2, 0x1
00FA  F001     NOP
00FC  500E     MOVF L_ptr, W, ACCESS
00FE  26D9     ADDWF FSR2, F, ACCESS
0100  500F     MOVF 0xF, W, ACCESS
0102  22DA     ADDWFC FSR2H, F, ACCESS
0104  CFDE     MOVFF POSTINC2, 0x67
0106  F067     NOP
0108  CFDD     MOVFF POSTDEC2, 0x68
010A  F068     NOP
010C  EE20     LFSR 2, 0x3
010E  F003     NOP
0110  500E     MOVF L_ptr, W, ACCESS
0112  26D9     ADDWF FSR2, F, ACCESS
0114  500F     MOVF 0xF, W, ACCESS
0116  22DA     ADDWFC FSR2H, F, ACCESS
0118  5067     MOVF 0x67, W, ACCESS
011A  5EDE     SUBWF POSTINC2, F, ACCESS
011C  5068     MOVF 0x68, W, ACCESS
011E  5ADD     SUBWFB POSTDEC2, F, ACCESS
111:           			if (L_ptr->strobe < l_full)
0120  EE20     LFSR 2, 0x3
0122  F003     NOP
0124  500E     MOVF L_ptr, W, ACCESS
0126  26D9     ADDWF FSR2, F, ACCESS
0128  500F     MOVF 0xF, W, ACCESS
012A  22DA     ADDWFC FSR2H, F, ACCESS
012C  507B     MOVF l_full, W, ACCESS
012E  5CDE     SUBWF POSTINC2, W, ACCESS
0130  507C     MOVF 0x7C, W, ACCESS
0132  58DE     SUBWFB POSTINC2, W, ACCESS
0134  B0D8     BTFSC STATUS, 0, ACCESS
0136  D019     BRA 0x16A
112:           				L_ptr->strobe = strobe_limit_h;
0138  EE20     LFSR 2, 0x3
013A  F003     NOP
013C  500E     MOVF L_ptr, W, ACCESS
013E  26D9     ADDWF FSR2, F, ACCESS
0140  500F     MOVF 0xF, W, ACCESS
0142  22DA     ADDWFC FSR2H, F, ACCESS
0144  0EFA     MOVLW 0xFA
0146  6EDE     MOVWF POSTINC2, ACCESS
0148  0EFF     MOVLW 0xFF
014A  6EDD     MOVWF POSTDEC2, ACCESS
113:           			break;
114:           		}
014C  D00E     BRA 0x16A
115:           		V.line_num++;
016A  0E01     MOVLW 0x1
016C  6E67     MOVWF 0x67, ACCESS
016E  3003     RRCF 0x3, W, ACCESS
0170  6E68     MOVWF 0x68, ACCESS
0172  3068     RRCF 0x68, W, ACCESS
0174  0B03     ANDLW 0x3
0176  6E68     MOVWF 0x68, ACCESS
0178  5067     MOVF 0x67, W, ACCESS
017A  2668     ADDWF 0x68, F, ACCESS
017C  3668     RLCF 0x68, F, ACCESS
017E  3668     RLCF 0x68, F, ACCESS
0180  5003     MOVF 0x3, W, ACCESS
0182  1868     XORWF 0x68, W, ACCESS
0184  0BF3     ANDLW 0xF3
0186  1868     XORWF 0x68, W, ACCESS
0188  6E03     MOVWF 0x3, ACCESS
116:           		if (L_ptr->sequence.end || (V.line_num >= strobe_max)) { // rollover for sequence patterns
018A  C00E     MOVFF L_ptr, FSR2
018C  FFD9     NOP
018E  C00F     MOVFF 0xF, FSR2H
0190  FFDA     NOP
0192  B8DF     BTFSC INDF2, 4, ACCESS
0194  D007     BRA 0x1A4
0196  3003     RRCF 0x3, W, ACCESS
0198  32E8     RRCF WREG, F, ACCESS
019A  0B03     ANDLW 0x3
019C  6E67     MOVWF 0x67, ACCESS
019E  0E0F     MOVLW 0xF
01A0  6467     CPFSGT 0x67, ACCESS
01A2  D004     BRA 0x1AC
117:           			V.line_num = 0;
01A4  0EF3     MOVLW 0xF3
01A6  1603     ANDWF 0x3, F, ACCESS
118:           			V.sequences++;
01A8  4A08     INFSNZ 0x8, F, ACCESS
01AA  2A09     INCF 0x9, F, ACCESS
119:           		}
120:           	}
121:           
122:           	if (PIR1bits.TMR1IF || l_state == 0) { // Timer1 int handler, for strobe timing
01AC  B09E     BTFSC PIR1, 0, ACCESS
01AE  D003     BRA 0x1B6
01B0  507D     MOVF l_state, W, ACCESS
01B2  A4D8     BTFSS STATUS, 2, ACCESS
01B4  D050     BRA 0x256
123:           		PIR1bits.TMR1IF = FALSE;
01B6  909E     BCF PIR1, 0, ACCESS
124:           
125:           		switch (l_state) {
01B8  D045     BRA 0x244
0244  507D     MOVF l_state, W, ACCESS
0246  0A00     XORLW 0x0
0248  B4D8     BTFSC STATUS, 2, ACCESS
024A  D7B7     BRA 0x1BA
024C  0A01     XORLW 0x1
024E  B4D8     BTFSC STATUS, 2, ACCESS
0250  D7D0     BRA 0x1F2
0252  0A03     XORLW 0x3
0254  D7EE     BRA 0x232
126:           		case 0:
127:           			WRITETIMER1(L_ptr->strobe); // strobe positioning during rotation
01BA  EE20     LFSR 2, 0x3
01BC  F003     NOP
01BE  500E     MOVF L_ptr, W, ACCESS
01C0  26D9     ADDWF FSR2, F, ACCESS
01C2  500F     MOVF 0xF, W, ACCESS
01C4  22DA     ADDWFC FSR2H, F, ACCESS
01C6  CFDE     MOVFF POSTINC2, 0x67
01C8  F067     NOP
01CA  CFDD     MOVFF POSTDEC2, 0x68
01CC  F068     NOP
01CE  C068     MOVFF 0x68, 0x67
01D0  F067     NOP
01D2  6A68     CLRF 0x68, ACCESS
01D4  5067     MOVF 0x67, W, ACCESS
01D6  6ECF     MOVWF TMR1H, ACCESS
01D8  EE20     LFSR 2, 0x3
01DA  F003     NOP
01DC  500E     MOVF L_ptr, W, ACCESS
01DE  26D9     ADDWF FSR2, F, ACCESS
01E0  500F     MOVF 0xF, W, ACCESS
01E2  22DA     ADDWFC FSR2H, F, ACCESS
01E4  50DF     MOVF INDF2, W, ACCESS
01E6  6ECE     MOVWF TMR1, ACCESS
128:           			G_OUT = 0;
01E8  9089     BCF LATA, 0, ACCESS
129:           			R_OUT = 0;
01EA  9289     BCF LATA, 1, ACCESS
130:           			B_OUT = 0;
01EC  9489     BCF LATA, 2, ACCESS
131:           			l_state = 1; // off time after index to start time
01EE  0E01     MOVLW 0x1
01F0  D01E     BRA 0x22E
132:           			break;
133:           		case 1:
134:           			WRITETIMER1(l_width);
01F2  0100     MOVLB 0x0
01F4  51D5     MOVF 0xD5, W, BANKED
01F6  6ECF     MOVWF TMR1H, ACCESS
01F8  C0D4     MOVFF l_width, TMR1
01FA  FFCE     NOP
135:           			if (!L_ptr->sequence.skip) {
01FC  C00E     MOVFF L_ptr, FSR2
01FE  FFD9     NOP
0200  C00F     MOVFF 0xF, FSR2H
0202  FFDA     NOP
0204  BADF     BTFSC INDF2, 5, ACCESS
0206  D012     BRA 0x22C
136:           				if (L_ptr->sequence.R)
0208  C00E     MOVFF L_ptr, FSR2
020A  FFD9     NOP
020C  C00F     MOVFF 0xF, FSR2H
020E  FFDA     NOP
0210  B2DF     BTFSC INDF2, 1, ACCESS
137:           					R_OUT = 1;
0212  8289     BSF LATA, 1, ACCESS
138:           				if (L_ptr->sequence.G)
0214  C00E     MOVFF L_ptr, FSR2
0216  FFD9     NOP
0218  C00F     MOVFF 0xF, FSR2H
021A  FFDA     NOP
021C  B4DF     BTFSC INDF2, 2, ACCESS
139:           					G_OUT = 1;
021E  8089     BSF LATA, 0, ACCESS
140:           				if (L_ptr->sequence.B)
0220  C00E     MOVFF L_ptr, FSR2
0222  FFD9     NOP
0224  C00F     MOVFF 0xF, FSR2H
0226  FFDA     NOP
0228  B6DF     BTFSC INDF2, 3, ACCESS
141:           					B_OUT = 1;
022A  8489     BSF LATA, 2, ACCESS
142:           			}
143:           
144:           			l_state = 2; // on start time duration for strobe pulse
022C  0E02     MOVLW 0x2
022E  6E7D     MOVWF l_state, ACCESS
145:           			break;
0230  D012     BRA 0x256
146:           		case 2:
147:           			WRITETIMER1(l_complete);
148:           			G_OUT = 0; // wait to next rotation
149:           			R_OUT = 0;
150:           			B_OUT = 0;
151:           			break;
152:           		default:
153:           			WRITETIMER1(l_complete);
0232  0100     MOVLB 0x0
0234  51D3     MOVF 0xD3, W, BANKED
0236  6ECF     MOVWF TMR1H, ACCESS
0238  C0D2     MOVFF l_complete, TMR1
023A  FFCE     NOP
154:           			G_OUT = 0;
023C  9089     BCF LATA, 0, ACCESS
155:           			R_OUT = 0;
023E  9289     BCF LATA, 1, ACCESS
156:           			B_OUT = 0;
0240  9489     BCF LATA, 2, ACCESS
157:           			break;
158:           		}
0242  D009     BRA 0x256
159:           	}
160:           
161:           	if (PIR1bits.RCIF) { // is data from RS-232 port
0256  AA9E     BTFSS PIR1, 5, ACCESS
0258  D00F     BRA 0x278
162:           		V.rx_data = RCREG;
025A  CFAE     MOVFF RCREG, 0x4
025C  F004     NOP
163:           		if (RCSTAbits.OERR) {
025E  A2AB     BTFSS RCSTA, 1, ACCESS
0260  D002     BRA 0x266
164:           			RCSTAbits.CREN = 0; // clear overrun
0262  98AB     BCF RCSTA, 4, ACCESS
165:           			RCSTAbits.CREN = 1; // re-enable
0264  88AB     BSF RCSTA, 4, ACCESS
166:           		}
167:           		ringBufS_put(&ring_buf1, V.rx_data);
0266  0EA3     MOVLW 0xA3
0268  6E63     MOVWF _this, ACCESS
026A  0E00     MOVLW 0x0
026C  6E64     MOVWF 0x64, ACCESS
026E  C004     MOVFF 0x4, c
0270  F065     NOP
0272  ECA4     CALL 0x948, 0
0274  F004     NOP
168:           		V.comm = TRUE;
0276  8201     BSF V, 1, ACCESS
169:           	}
170:           
171:           
172:           	if (INTCONbits.TMR0IF) { //      check timer0 
0278  A4F2     BTFSS INTCON, 2, ACCESS
027A  D013     BRA 0x2A2
173:           		INTCONbits.TMR0IF = FALSE; //      clear interrupt flag
027C  94F2     BCF INTCON, 2, ACCESS
174:           		WRITETIMER0(timer0_off);
027E  0100     MOVLB 0x0
0280  51D9     MOVF 0xD9, W, BANKED
0282  6ED7     MOVWF TMR0H, ACCESS
0284  C0D8     MOVFF timer0_off, TMR0
0286  FFD6     NOP
175:           		LED5 = (uint8_t)!LED5; // active LED blinker
0288  BE8A     BTFSC LATB, 7, ACCESS
028A  D003     BRA 0x292
028C  6A67     CLRF 0x67, ACCESS
028E  2A67     INCF 0x67, F, ACCESS
0290  D001     BRA 0x294
0292  6A67     CLRF 0x67, ACCESS
0294  3267     RRCF 0x67, F, ACCESS
0296  3267     RRCF 0x67, F, ACCESS
0298  508A     MOVF LATB, W, ACCESS
029A  1867     XORWF 0x67, W, ACCESS
029C  0B7F     ANDLW 0x7F
029E  1867     XORWF 0x67, W, ACCESS
02A0  6E8A     MOVWF LATB, ACCESS
176:           	}
177:           
178:           }
02A2  C07A     MOVFF 0x7A, 0x81
179:           
180:           void USART_putc(uint8_t c)
0C90  0100     MOVLB 0x0
0C92  6FB6     MOVWF __pcstackBANK0, BANKED
181:           {
182:           	while (!TXSTAbits.TRMT);
0C94  A2AC     BTFSS TXSTA, 1, ACCESS
0C96  D7FE     BRA 0xC94
183:           	TXREG = c;
0C98  C0B6     MOVFF __pcstackBANK0, TXREG
0C9A  FFAD     NOP
184:           }
0008  827E     BSF btemp, 1, ACCESS
000A  CFFA     MOVFF PCLATH, 0x69
000C  F069     NOP
000E  CFFB     MOVFF PCLATU, 0x6A
0010  F06A     NOP
0012  CFE9     MOVFF FSR0, 0x6B
0014  F06B     NOP
0016  CFEA     MOVFF FSR0H, 0x6C
0018  F06C     NOP
001A  CFE1     MOVFF FSR1, 0x6D
001C  F06D     NOP
001E  CFE2     MOVFF FSR1H, 0x6E
0020  F06E     NOP
0022  CFD9     MOVFF FSR2, 0x6F
0024  F06F     NOP
0026  CFDA     MOVFF FSR2H, 0x70
0028  F070     NOP
002A  CFF3     MOVFF PROD, 0x71
002C  F071     NOP
002E  CFF4     MOVFF PRODH, 0x72
0030  F072     NOP
0032  CFF6     MOVFF TBLPTR, 0x73
0034  F073     NOP
0036  CFF7     MOVFF TBLPTRH, 0x74
0038  F074     NOP
003A  CFF8     MOVFF TBLPTRU, 0x75
003C  F075     NOP
003E  CFF5     MOVFF TABLAT, 0x76
0040  F076     NOP
0042  C07E     MOVFF btemp, 0x77
0044  F077     NOP
0046  C07F     MOVFF 0x7F, 0x78
0048  F078     NOP
004A  C080     MOVFF __pbssBANK0, 0x79
004C  F079     NOP
004E  C081     MOVFF 0x81, 0x7A
0050  F07A     NOP
0C9C  0012     RETURN 0
185:           
186:           void USART_puts(uint8_t *s)
187:           {
188:           	while (*s) {
0BE0  D00A     BRA 0xBF6
189:           		USART_putc(*s);
0BE2  C0B7     MOVFF value, FSR2
0BE4  FFD9     NOP
0BE6  C0B8     MOVFF c, FSR2H
0BE8  FFDA     NOP
0BEA  50DF     MOVF INDF2, W, ACCESS
0BEC  EC48     CALL 0xC90, 0
0BEE  F006     NOP
190:           		s++;
0BF0  0100     MOVLB 0x0
0BF2  4BB7     INFSNZ value, F, BANKED
0BF4  2BB8     INCF c, F, BANKED
191:           	}
0BF6  C0B7     MOVFF value, FSR2
0BF8  FFD9     NOP
0BFA  C0B8     MOVFF c, FSR2H
0BFC  FFDA     NOP
0BFE  50DF     MOVF INDF2, W, ACCESS
0C00  B4D8     BTFSC STATUS, 2, ACCESS
0C02  0012     RETURN 0
0C04  D7EE     BRA 0xBE2
192:           }
193:           
194:           void USART_putsr(const uint8_t *s)
195:           {
196:           	while (*s) {
0BB4  D00B     BRA 0xBCC
197:           		USART_putc(*s);
0BB6  C0B7     MOVFF value, TBLPTR
0BB8  FFF6     NOP
0BBA  C0B8     MOVFF c, TBLPTRH
0BBC  FFF7     NOP
0BBE  0008     TBLRD*
0BC0  50F5     MOVF TABLAT, W, ACCESS
0BC2  EC48     CALL 0xC90, 0
0BC4  F006     NOP
198:           		s++;
0BC6  0100     MOVLB 0x0
0BC8  4BB7     INFSNZ value, F, BANKED
0BCA  2BB8     INCF c, F, BANKED
199:           	}
0BCC  C0B7     MOVFF value, TBLPTR
0BCE  FFF6     NOP
0BD0  C0B8     MOVFF c, TBLPTRH
0BD2  FFF7     NOP
0BD4  0008     TBLRD*
0BD6  50F5     MOVF TABLAT, W, ACCESS
0BD8  0900     IORLW 0x0
0BDA  B4D8     BTFSC STATUS, 2, ACCESS
0BDC  0012     RETURN 0
0BDE  D7EB     BRA 0xBB6
200:           }
201:           
202:           void puts_ok(uint16_t size)
203:           {
204:           	itoa(str, size, 10);
0B48  0E8B     MOVLW 0x8B
0B4A  0100     MOVLB 0x0
0B4C  6FC6     MOVWF buf, BANKED
0B4E  0E00     MOVLW 0x0
0B50  6FC7     MOVWF 0xC7, BANKED
0B52  C0CE     MOVFF size, val
0B54  F0C8     NOP
0B56  C0CF     MOVFF 0xCF, 0xC9
0B58  F0C9     NOP
0B5A  0E00     MOVLW 0x0
0B5C  6FCB     MOVWF 0xCB, BANKED
0B5E  0E0A     MOVLW 0xA
0B60  6FCA     MOVWF base, BANKED
0B62  EC60     CALL 0xAC0, 0
0B64  F005     NOP
205:           	USART_putsr("\r\n OK");
0B66  0E58     MOVLW 0x58
0B68  0100     MOVLB 0x0
0B6A  6FB7     MOVWF value, BANKED
0B6C  0E03     MOVLW 0x3
0B6E  6FB8     MOVWF c, BANKED
0B70  ECDA     CALL 0xBB4, 0
0B72  F005     NOP
206:           	USART_puts(str); // send size of data array
0B74  0E8B     MOVLW 0x8B
0B76  0100     MOVLB 0x0
0B78  6FB7     MOVWF value, BANKED
0B7A  0E00     MOVLW 0x0
0B7C  6FB8     MOVWF c, BANKED
0B7E  ECF0     CALL 0xBE0, 0
0B80  F005     NOP
207:           }
0B82  0012     RETURN 0
208:           
209:           /* main loop routine */
210:           int16_t sw_work(void)
211:           {
212:           	static uint8_t position = 0, offset = 0, rx_data;
213:           	static uint8_t *L_tmp_ptr;
214:           
215:           	static union L_union_type { // so we can access each byte of the struct
216:           		uint8_t L_bytes[sizeof(L[0]) + 1];
217:           		L_data L_tmp;
218:           	} L_union;
219:           
220:           	ClrWdt(); // reset watchdog
0366  0004     CLRWDT
221:           
222:           	if (!SW1) {
0368  B880     BTFSC PORTA, 4, ACCESS
036A  D041     BRA 0x3EE
223:           		USART_putsr("\r\nTimer limit ");
036C  0E1A     MOVLW 0x1A
036E  0100     MOVLB 0x0
0370  6FB7     MOVWF value, BANKED
0372  0E03     MOVLW 0x3
0374  6FB8     MOVWF c, BANKED
0376  ECDA     CALL 0xBB4, 0
0378  F005     NOP
224:           		itoa(str, l_full, 10);
037A  0E8B     MOVLW 0x8B
037C  0100     MOVLB 0x0
037E  6FC6     MOVWF buf, BANKED
0380  0E00     MOVLW 0x0
0382  6FC7     MOVWF 0xC7, BANKED
0384  C07B     MOVFF l_full, val
0386  F0C8     NOP
0388  C07C     MOVFF 0x7C, 0xC9
038A  F0C9     NOP
038C  0E00     MOVLW 0x0
038E  6FCB     MOVWF 0xCB, BANKED
0390  0E0A     MOVLW 0xA
0392  6FCA     MOVWF base, BANKED
0394  EC60     CALL 0xAC0, 0
0396  F005     NOP
225:           		USART_puts(str);
0398  0E8B     MOVLW 0x8B
039A  0100     MOVLB 0x0
039C  6FB7     MOVWF value, BANKED
039E  0E00     MOVLW 0x0
03A0  6FB8     MOVWF c, BANKED
03A2  ECF0     CALL 0xBE0, 0
03A4  F005     NOP
226:           		USART_putsr("Timer value ");
03A6  0E29     MOVLW 0x29
03A8  0100     MOVLB 0x0
03AA  6FB7     MOVWF value, BANKED
03AC  0E03     MOVLW 0x3
03AE  6FB8     MOVWF c, BANKED
03B0  ECDA     CALL 0xBB4, 0
03B2  F005     NOP
227:           		itoa(str, L_ptr->strobe, 10);
03B4  0E8B     MOVLW 0x8B
03B6  0100     MOVLB 0x0
03B8  6FC6     MOVWF buf, BANKED
03BA  0E00     MOVLW 0x0
03BC  6FC7     MOVWF 0xC7, BANKED
03BE  EE20     LFSR 2, 0x3
03C0  F003     NOP
03C2  500E     MOVF L_ptr, W, ACCESS
03C4  26D9     ADDWF FSR2, F, ACCESS
03C6  500F     MOVF 0xF, W, ACCESS
03C8  22DA     ADDWFC FSR2H, F, ACCESS
03CA  CFDE     MOVFF POSTINC2, val
03CC  F0C8     NOP
03CE  CFDD     MOVFF POSTDEC2, 0xC9
03D0  F0C9     NOP
03D2  0E00     MOVLW 0x0
03D4  6FCB     MOVWF 0xCB, BANKED
03D6  0E0A     MOVLW 0xA
03D8  6FCA     MOVWF base, BANKED
03DA  EC60     CALL 0xAC0, 0
03DC  F005     NOP
228:           		USART_puts(str);
03DE  0E8B     MOVLW 0x8B
03E0  0100     MOVLB 0x0
03E2  6FB7     MOVWF value, BANKED
03E4  0E00     MOVLW 0x0
03E6  6FB8     MOVWF c, BANKED
03E8  ECF0     CALL 0xBE0, 0
03EA  F005     NOP
229:           		LED1 = 1;
03EC  8689     BSF LATA, 3, ACCESS
230:           	}
231:           
232:           	/* command state machine 
233:           	 * u update the current display buffer with remote rs232 data
234:           	 * d display the current display buffer with rs232 data
235:           	 */
236:           	if (!ringBufS_empty(&ring_buf1)) {
03EE  0EA3     MOVLW 0xA3
03F0  0100     MOVLB 0x0
03F2  6FB6     MOVWF __pcstackBANK0, BANKED
03F4  0E00     MOVLW 0x0
03F6  6FB7     MOVWF value, BANKED
03F8  EC22     CALL 0xC44, 0
03FA  F006     NOP
03FC  0900     IORLW 0x0
03FE  A4D8     BTFSS STATUS, 2, ACCESS
0400  0012     RETURN 0
237:           		rx_data = ringBufS_get(&ring_buf1);
0402  0EA3     MOVLW 0xA3
0404  0100     MOVLB 0x0
0406  6FB9     MOVWF _this, BANKED
0408  0E00     MOVLW 0x0
040A  6FBA     MOVWF n, BANKED
040C  EC69     CALL 0x8D2, 0
040E  F004     NOP
0410  0100     MOVLB 0x0
0412  6F88     MOVWF rx_data, BANKED
238:           		switch (V.comm_state) {
0414  D128     BRA 0x666
0666  5002     MOVF 0x2, W, ACCESS
0668  0A00     XORLW 0x0
066A  B4D8     BTFSC STATUS, 2, ACCESS
066C  D702     BRA 0x472
066E  0A01     XORLW 0x1
0670  B4D8     BTFSC STATUS, 2, ACCESS
0672  D71A     BRA 0x4A8
0674  0A03     XORLW 0x3
0676  B4D8     BTFSC STATUS, 2, ACCESS
0678  D757     BRA 0x528
067A  0A01     XORLW 0x1
067C  B4D8     BTFSC STATUS, 2, ACCESS
067E  D714     BRA 0x4A8
0680  0A07     XORLW 0x7
0682  B4D8     BTFSC STATUS, 2, ACCESS
0684  D779     BRA 0x578
0686  0A01     XORLW 0x1
0688  B4D8     BTFSC STATUS, 2, ACCESS
068A  D70E     BRA 0x4A8
068C  0A03     XORLW 0x3
068E  B4D8     BTFSC STATUS, 2, ACCESS
0690  D70B     BRA 0x4A8
0692  D7CB     BRA 0x62A
239:           		case APP_STATE_INIT:
240:           			switch (rx_data) {
0472  0100     MOVLB 0x0
0474  5188     MOVF rx_data, W, BANKED
0476  0A44     XORLW 0x44
0478  B4D8     BTFSC STATUS, 2, ACCESS
047A  D7D7     BRA 0x42A
047C  0A01     XORLW 0x1
047E  B4D8     BTFSC STATUS, 2, ACCESS
0480  D7E6     BRA 0x44E
0482  0A10     XORLW 0x10
0484  B4D8     BTFSC STATUS, 2, ACCESS
0486  D7C7     BRA 0x416
0488  0A0F     XORLW 0xF
048A  B4D8     BTFSC STATUS, 2, ACCESS
048C  0012     RETURN 0
048E  0A3E     XORLW 0x3E
0490  B4D8     BTFSC STATUS, 2, ACCESS
0492  D7CB     BRA 0x42A
0494  0A01     XORLW 0x1
0496  B4D8     BTFSC STATUS, 2, ACCESS
0498  D7D1     BRA 0x43C
049A  0A10     XORLW 0x10
049C  B4D8     BTFSC STATUS, 2, ACCESS
049E  D7BB     BRA 0x416
04A0  0A0F     XORLW 0xF
04A2  B4D8     BTFSC STATUS, 2, ACCESS
04A4  0012     RETURN 0
04A6  D7DC     BRA 0x460
241:           			case 'u':
242:           			case 'U':
243:           				LED1 = 1;
0416  8689     BSF LATA, 3, ACCESS
244:           				V.comm_state = APP_STATE_WAIT_FOR_UDATA;
0418  0E01     MOVLW 0x1
041A  6E02     MOVWF 0x2, ACCESS
245:           				puts_ok(V.l_size); // ok each valid command
041C  C00C     MOVFF 0xC, size
041E  F0CE     NOP
0420  C00D     MOVFF 0xD, 0xCF
0422  F0CF     NOP
0424  ECA4     CALL 0xB48, 0
0426  F005     NOP
246:           				break;
0428  0012     RETURN 0
247:           			case 'd':
248:           			case 'D':
249:           				V.comm_state = APP_STATE_WAIT_FOR_DDATA;
042A  0E03     MOVLW 0x3
042C  6E02     MOVWF 0x2, ACCESS
250:           				puts_ok(V.l_size);
042E  C00C     MOVFF 0xC, size
0430  F0CE     NOP
0432  C00D     MOVFF 0xD, 0xCF
0434  F0CF     NOP
0436  ECA4     CALL 0xB48, 0
0438  F005     NOP
251:           				break;
043A  0012     RETURN 0
252:           			case 'e':
253:           				V.comm_state = APP_STATE_WAIT_FOR_eDATA;
043C  0E05     MOVLW 0x5
043E  6E02     MOVWF 0x2, ACCESS
254:           				puts_ok(V.l_size);
0440  C00C     MOVFF 0xC, size
0442  F0CE     NOP
0444  C00D     MOVFF 0xD, 0xCF
0446  F0CF     NOP
0448  ECA4     CALL 0xB48, 0
044A  F005     NOP
255:           				break;
044C  0012     RETURN 0
256:           			case 'E':
257:           				V.comm_state = APP_STATE_WAIT_FOR_EDATA;
044E  0E06     MOVLW 0x6
0450  6E02     MOVWF 0x2, ACCESS
258:           				puts_ok(V.l_size);
0452  C00C     MOVFF 0xC, size
0454  F0CE     NOP
0456  C00D     MOVFF 0xD, 0xCF
0458  F0CF     NOP
045A  ECA4     CALL 0xB48, 0
045C  F005     NOP
259:           				break;
260:           			case 'z':
261:           			case 'Z': // null command for fillers, silent
262:           				break;
045E  0012     RETURN 0
263:           			default:
264:           				USART_putsr("\r\n NAK_I");
0460  0E41     MOVLW 0x41
0462  0100     MOVLB 0x0
0464  6FB7     MOVWF value, BANKED
0466  0E03     MOVLW 0x3
0468  6FB8     MOVWF c, BANKED
046A  ECDA     CALL 0xBB4, 0
046C  F005     NOP
265:           				LED1 = 0;
046E  9689     BCF LATA, 3, ACCESS
266:           				break;
267:           			}
0470  0012     RETURN 0
268:           			break;
269:           		case APP_STATE_WAIT_FOR_eDATA:
270:           		case APP_STATE_WAIT_FOR_EDATA:
271:           		case APP_STATE_WAIT_FOR_DDATA:
272:           		case APP_STATE_WAIT_FOR_UDATA:
273:           			position = rx_data;
04A8  C088     MOVFF rx_data, position
04AA  F08A     NOP
274:           			if (position >= strobe_max) {
04AC  0E0F     MOVLW 0xF
04AE  0100     MOVLB 0x0
04B0  658A     CPFSGT position, BANKED
04B2  D00A     BRA 0x4C8
275:           				USART_putsr(" NAK_D");
04B4  0E51     MOVLW 0x51
04B6  6FB7     MOVWF value, BANKED
04B8  0E03     MOVLW 0x3
04BA  6FB8     MOVWF c, BANKED
04BC  ECDA     CALL 0xBB4, 0
04BE  F005     NOP
276:           				V.comm_state = APP_STATE_INIT;
04C0  0E00     MOVLW 0x0
04C2  6E02     MOVWF 0x2, ACCESS
277:           				LED1 = 0;
04C4  9689     BCF LATA, 3, ACCESS
278:           				break;
04C6  0012     RETURN 0
279:           			}
280:           			offset = 0;
04C8  0E00     MOVLW 0x0
04CA  0100     MOVLB 0x0
04CC  6F89     MOVWF offset, BANKED
281:           			switch (V.comm_state) {
04CE  D018     BRA 0x500
0500  5002     MOVF 0x2, W, ACCESS
0502  0A01     XORLW 0x1
0504  B4D8     BTFSC STATUS, 2, ACCESS
0506  D7E4     BRA 0x4D0
0508  0A02     XORLW 0x2
050A  B4D8     BTFSC STATUS, 2, ACCESS
050C  D7F7     BRA 0x4FC
050E  0A06     XORLW 0x6
0510  B4D8     BTFSC STATUS, 2, ACCESS
0512  D7E1     BRA 0x4D6
0514  0A03     XORLW 0x3
0516  B4D8     BTFSC STATUS, 2, ACCESS
0518  D7E8     BRA 0x4EA
282:           			case APP_STATE_WAIT_FOR_UDATA:
283:           				V.comm_state = APP_STATE_WAIT_FOR_RDATA;
04D0  0E02     MOVLW 0x2
284:           				break;
285:           			case APP_STATE_WAIT_FOR_DDATA:
286:           				V.comm_state = APP_STATE_WAIT_FOR_SDATA;
04D2  6E02     MOVWF 0x2, ACCESS
287:           				break;
04D4  D022     BRA 0x51A
288:           			case APP_STATE_WAIT_FOR_eDATA:
289:           				L[position].sequence.end = 0; // clear end flag
04D6  518A     MOVF position, W, BANKED
04D8  0D05     MULLW 0x5
04DA  0E10     MOVLW 0x10
04DC  24F3     ADDWF PROD, W, ACCESS
04DE  6ED9     MOVWF FSR2, ACCESS
04E0  0E00     MOVLW 0x0
04E2  20F4     ADDWFC PRODH, W, ACCESS
04E4  6EDA     MOVWF FSR2H, ACCESS
04E6  98DF     BCF INDF2, 4, ACCESS
290:           				V.comm_state = APP_STATE_WAIT_FOR_SDATA;
04E8  D009     BRA 0x4FC
291:           				break;
292:           			case APP_STATE_WAIT_FOR_EDATA:
293:           				L[position].sequence.end = 1; // set end flag
04EA  518A     MOVF position, W, BANKED
04EC  0D05     MULLW 0x5
04EE  0E10     MOVLW 0x10
04F0  24F3     ADDWF PROD, W, ACCESS
04F2  6ED9     MOVWF FSR2, ACCESS
04F4  0E00     MOVLW 0x0
04F6  20F4     ADDWFC PRODH, W, ACCESS
04F8  6EDA     MOVWF FSR2H, ACCESS
04FA  88DF     BSF INDF2, 4, ACCESS
294:           				V.comm_state = APP_STATE_WAIT_FOR_SDATA;
04FC  0E04     MOVLW 0x4
04FE  D7E9     BRA 0x4D2
295:           				break;
296:           			default:
297:           				break;
298:           			}
299:           			USART_putsr(" OK");
051A  0E5A     MOVLW 0x5A
051C  6FB7     MOVWF value, BANKED
051E  0E03     MOVLW 0x3
0520  6FB8     MOVWF c, BANKED
0522  ECDA     CALL 0xBB4, 0
0524  F005     NOP
300:           			break;
0526  0012     RETURN 0
301:           		case APP_STATE_WAIT_FOR_RDATA: // receive
302:           			L_union.L_bytes[offset] = rx_data;
0528  0100     MOVLB 0x0
052A  5189     MOVF offset, W, BANKED
052C  0D01     MULLW 0x1
052E  0E80     MOVLW 0x80
0530  24F3     ADDWF PROD, W, ACCESS
0532  6ED9     MOVWF FSR2, ACCESS
0534  0E00     MOVLW 0x0
0536  20F4     ADDWFC PRODH, W, ACCESS
0538  6EDA     MOVWF FSR2H, ACCESS
053A  C088     MOVFF rx_data, INDF2
053C  FFDF     NOP
303:           			offset++;
053E  2B89     INCF offset, F, BANKED
304:           			if (offset >= sizeof(L_union.L_tmp)) {
0540  0E04     MOVLW 0x4
0542  6589     CPFSGT offset, BANKED
0544  0012     RETURN 0
305:           				L[position] = L_union.L_tmp;
0546  EE20     LFSR 2, 0x80
0548  F080     NOP
054A  518A     MOVF position, W, BANKED
054C  0D05     MULLW 0x5
054E  0E10     MOVLW 0x10
0550  24F3     ADDWF PROD, W, ACCESS
0552  6EE1     MOVWF FSR1, ACCESS
0554  0E00     MOVLW 0x0
0556  20F4     ADDWFC PRODH, W, ACCESS
0558  6EE2     MOVWF FSR1H, ACCESS
055A  0E04     MOVLW 0x4
055C  CFDB     MOVFF PLUSW2, PLUSW1
055E  FFE3     NOP
0560  06E8     DECF WREG, F, ACCESS
0562  E2FC     BC 0x55C
306:           				V.comm_state = APP_STATE_INIT;
0564  0E00     MOVLW 0x0
0566  6E02     MOVWF 0x2, ACCESS
307:           				USART_putsr(" OK");
0568  0E5A     MOVLW 0x5A
056A  6FB7     MOVWF value, BANKED
056C  0E03     MOVLW 0x3
056E  6FB8     MOVWF c, BANKED
0570  ECDA     CALL 0xBB4, 0
0572  F005     NOP
308:           				LED1 = 0;
0574  9689     BCF LATA, 3, ACCESS
309:           			}
310:           			break;
0576  0012     RETURN 0
311:           		case APP_STATE_WAIT_FOR_SDATA: // send
312:           			L_tmp_ptr = (void*) &L[position]; // set array start position
0578  0100     MOVLB 0x0
057A  518A     MOVF position, W, BANKED
057C  0D05     MULLW 0x5
057E  0E10     MOVLW 0x10
0580  24F3     ADDWF PROD, W, ACCESS
0582  6F86     MOVWF L_tmp_ptr, BANKED
0584  0E00     MOVLW 0x0
0586  20F4     ADDWFC PRODH, W, ACCESS
0588  6F87     MOVWF 0x87, BANKED
313:           			do { // send ascii data to the rs232 port
314:           				USART_putsr(" ,");
058A  0E61     MOVLW 0x61
058C  6FB7     MOVWF value, BANKED
058E  0E03     MOVLW 0x3
0590  6FB8     MOVWF c, BANKED
0592  ECDA     CALL 0xBB4, 0
0594  F005     NOP
315:           				if (offset) {
0596  0100     MOVLB 0x0
0598  5189     MOVF offset, W, BANKED
059A  B4D8     BTFSC STATUS, 2, ACCESS
059C  D014     BRA 0x5C6
316:           					itoa(str, *L_tmp_ptr, 16); // show hex
059E  0E8B     MOVLW 0x8B
05A0  6FC6     MOVWF buf, BANKED
05A2  0E00     MOVLW 0x0
05A4  6FC7     MOVWF 0xC7, BANKED
05A6  C086     MOVFF L_tmp_ptr, FSR2
05A8  FFD9     NOP
05AA  C087     MOVFF 0x87, FSR2H
05AC  FFDA     NOP
05AE  50DF     MOVF INDF2, W, ACCESS
05B0  6FD0     MOVWF 0xD0, BANKED
05B2  51D0     MOVF 0xD0, W, BANKED
05B4  6FC8     MOVWF val, BANKED
05B6  6BC9     CLRF 0xC9, BANKED
05B8  0E00     MOVLW 0x0
05BA  6FCB     MOVWF 0xCB, BANKED
05BC  0E10     MOVLW 0x10
05BE  6FCA     MOVWF base, BANKED
05C0  EC60     CALL 0xAC0, 0
05C2  F005     NOP
317:           				} else {
05C4  D014     BRA 0x5EE
318:           					itoa(str, *L_tmp_ptr, 2); // show bits
05C6  0E8B     MOVLW 0x8B
05C8  0100     MOVLB 0x0
05CA  6FC6     MOVWF buf, BANKED
05CC  0E00     MOVLW 0x0
05CE  6FC7     MOVWF 0xC7, BANKED
05D0  C086     MOVFF L_tmp_ptr, FSR2
05D2  FFD9     NOP
05D4  C087     MOVFF 0x87, FSR2H
05D6  FFDA     NOP
05D8  50DF     MOVF INDF2, W, ACCESS
05DA  6FD0     MOVWF 0xD0, BANKED
05DC  51D0     MOVF 0xD0, W, BANKED
05DE  6FC8     MOVWF val, BANKED
05E0  6BC9     CLRF 0xC9, BANKED
05E2  0E00     MOVLW 0x0
05E4  6FCB     MOVWF 0xCB, BANKED
05E6  0E02     MOVLW 0x2
05E8  6FCA     MOVWF base, BANKED
05EA  EC60     CALL 0xAC0, 0
05EC  F005     NOP
319:           				}
320:           				USART_puts(str);
05EE  0E8B     MOVLW 0x8B
05F0  0100     MOVLB 0x0
05F2  6FB7     MOVWF value, BANKED
05F4  0E00     MOVLW 0x0
05F6  6FB8     MOVWF c, BANKED
05F8  ECF0     CALL 0xBE0, 0
05FA  F005     NOP
321:           				L_tmp_ptr++;
05FC  0100     MOVLB 0x0
05FE  4B86     INFSNZ L_tmp_ptr, F, BANKED
0600  2B87     INCF 0x87, F, BANKED
322:           				offset++;
0602  2B89     INCF offset, F, BANKED
323:           			} while (offset < V.l_size);
0604  5189     MOVF offset, W, BANKED
0606  6FD0     MOVWF 0xD0, BANKED
0608  6BD1     CLRF 0xD1, BANKED
060A  500C     MOVF 0xC, W, ACCESS
060C  5DD0     SUBWF 0xD0, W, BANKED
060E  500D     MOVF 0xD, W, ACCESS
0610  59D1     SUBWFB 0xD1, W, BANKED
0612  A0D8     BTFSS STATUS, 0, ACCESS
0614  D7BA     BRA 0x58A
324:           			V.comm_state = APP_STATE_INIT;
0616  0E00     MOVLW 0x0
0618  6E02     MOVWF 0x2, ACCESS
325:           			USART_putsr(" OK");
061A  0E5A     MOVLW 0x5A
061C  6FB7     MOVWF value, BANKED
061E  0E03     MOVLW 0x3
0620  6FB8     MOVWF c, BANKED
0622  ECDA     CALL 0xBB4, 0
0624  F005     NOP
326:           			LED1 = 0;
0626  9689     BCF LATA, 3, ACCESS
327:           			break;
0628  0012     RETURN 0
328:           		default:
329:           			USART_putsr(" NAK_C");
062A  0E4A     MOVLW 0x4A
062C  0100     MOVLB 0x0
062E  6FB7     MOVWF value, BANKED
0630  0E03     MOVLW 0x3
0632  6FB8     MOVWF c, BANKED
0634  ECDA     CALL 0xBB4, 0
0636  F005     NOP
330:           			V.comm_state = APP_STATE_INIT;
0638  0E00     MOVLW 0x0
063A  6E02     MOVWF 0x2, ACCESS
331:           			if (ringBufS_full(&ring_buf1))
063C  0EA3     MOVLW 0xA3
063E  0100     MOVLB 0x0
0640  6FB6     MOVWF __pcstackBANK0, BANKED
0642  0E00     MOVLW 0x0
0644  6FB7     MOVWF value, BANKED
0646  EC13     CALL 0xC26, 0
0648  F006     NOP
064A  0900     IORLW 0x0
064C  B4D8     BTFSC STATUS, 2, ACCESS
064E  D009     BRA 0x662
332:           				ringBufS_flush(&ring_buf1, 0);
0650  0EA3     MOVLW 0xA3
0652  0100     MOVLB 0x0
0654  6FBE     MOVWF _this, BANKED
0656  0E00     MOVLW 0x0
0658  6FBF     MOVWF val, BANKED
065A  0E00     MOVLW 0x0
065C  6FC0     MOVWF clearBuffer, BANKED
065E  EC0B     CALL 0xA16, 0
0660  F005     NOP
333:           			LED1 = 0;
0662  9689     BCF LATA, 3, ACCESS
334:           			break;
335:           		}
0664  0012     RETURN 0
0666  5002     MOVF 0x2, W, ACCESS
0668  0A00     XORLW 0x0
066A  B4D8     BTFSC STATUS, 2, ACCESS
066C  D702     BRA 0x472
066E  0A01     XORLW 0x1
0670  B4D8     BTFSC STATUS, 2, ACCESS
0672  D71A     BRA 0x4A8
0674  0A03     XORLW 0x3
0676  B4D8     BTFSC STATUS, 2, ACCESS
0678  D757     BRA 0x528
067A  0A01     XORLW 0x1
067C  B4D8     BTFSC STATUS, 2, ACCESS
067E  D714     BRA 0x4A8
0680  0A07     XORLW 0x7
0682  B4D8     BTFSC STATUS, 2, ACCESS
0684  D779     BRA 0x578
0686  0A01     XORLW 0x1
0688  B4D8     BTFSC STATUS, 2, ACCESS
068A  D70E     BRA 0x4A8
068C  0A03     XORLW 0x3
068E  B4D8     BTFSC STATUS, 2, ACCESS
0690  D70B     BRA 0x4A8
0692  D7CB     BRA 0x62A
336:           	}
337:           
338:           	return 0;
339:           }
340:           
341:           void init_rmsmon(void)
342:           {
343:           	/*
344:           	 * check for a clean POR
345:           	 */
346:           	V.boot_code = FALSE;
0840  9203     BCF 0x3, 1, ACCESS
347:           	if (RCON != 0b0011100)
0842  0E1C     MOVLW 0x1C
0844  18D0     XORWF RCON, W, ACCESS
0846  A4D8     BTFSS STATUS, 2, ACCESS
348:           		V.boot_code = TRUE;
0848  8203     BSF 0x3, 1, ACCESS
349:           
350:           	if (STKPTRbits.STKFUL || STKPTRbits.STKUNF) {
084A  BEFC     BTFSC STKPTR, 7, ACCESS
084C  D002     BRA 0x852
084E  ACFC     BTFSS STKPTR, 6, ACCESS
0850  D003     BRA 0x858
351:           		V.boot_code = TRUE;
0852  8203     BSF 0x3, 1, ACCESS
352:           		STKPTRbits.STKFUL = 0;
0854  9EFC     BCF STKPTR, 7, ACCESS
353:           		STKPTRbits.STKUNF = 0;
0856  9CFC     BCF STKPTR, 6, ACCESS
354:           	}
355:           
356:           	ADCON1 = 0x7F; // all digital, no ADC
0858  0E7F     MOVLW 0x7F
085A  6EC1     MOVWF ADCON1, ACCESS
357:           	/* interrupt priority ON */
358:           	RCONbits.IPEN = 1;
085C  8ED0     BSF RCON, 7, ACCESS
359:           	/* define I/O ports */
360:           	RMSPORTA = RMSPORT_IOA;
085E  0E10     MOVLW 0x10
0860  6E92     MOVWF TRISA, ACCESS
361:           	RMSPORTB = RMSPORT_IOB;
0862  0E11     MOVLW 0x11
0864  6E93     MOVWF TRISB, ACCESS
362:           
363:           	G_OUT = LEDON; // preset all LEDS
0866  9089     BCF LATA, 0, ACCESS
364:           	LED1 = LEDON;
0868  9689     BCF LATA, 3, ACCESS
365:           	LED2 = LEDON;
086A  9689     BCF LATA, 3, ACCESS
366:           	LED3 = LEDON;
086C  9689     BCF LATA, 3, ACCESS
367:           	LED4 = LEDON;
086E  9C8A     BCF LATB, 6, ACCESS
368:           	LED5 = LEDON;
0870  9E8A     BCF LATB, 7, ACCESS
369:           	LED6 = LEDON;
0872  9C89     BCF LATA, 6, ACCESS
370:           	RPMLED = LEDON;
0874  9A8A     BCF LATB, 5, ACCESS
371:           	timer0_off = TIMEROFFSET; // blink fast
0876  0E46     MOVLW 0x46
0878  0100     MOVLB 0x0
087A  6FD9     MOVWF 0xD9, BANKED
087C  0E50     MOVLW 0x50
087E  6FD8     MOVWF timer0_off, BANKED
372:           	//	OpenTimer0(TIMER_INT_ON & T0_16BIT & T0_SOURCE_INT & T0_PS_1_256); // led blinker
373:           	T0CON = 0b10000111;
0880  0E87     MOVLW 0x87
0882  6ED5     MOVWF T0CON, ACCESS
374:           	WRITETIMER0(timer0_off); //	start timer0 at ~1/2 second ticks
0884  51D9     MOVF 0xD9, W, BANKED
0886  6ED7     MOVWF TMR0H, ACCESS
0888  C0D8     MOVFF timer0_off, TMR0
088A  FFD6     NOP
375:           	//	OpenTimer1(TIMER_INT_ON & T1_16BIT_RW & T1_SOURCE_INT & T1_PS_1_2 & T1_OSC1EN_OFF & T1_SYNC_EXT_OFF); // strobe position clock
376:           	T1CON = 0b10010101;
088C  0E95     MOVLW 0x95
088E  6ECD     MOVWF T1CON, ACCESS
377:           	WRITETIMER1(timer1_off);
0890  51D7     MOVF 0xD7, W, BANKED
0892  6ECF     MOVWF TMR1H, ACCESS
0894  C0D6     MOVFF timer1_off, TMR1
0896  FFCE     NOP
378:           	/* data link */
379:           	COMM_ENABLE = TRUE; // for PICDEM4 onboard RS-232, not used on custom board
0898  868A     BSF LATB, 3, ACCESS
380:           	TXSTAbits.TXEN = 1;
089A  8AAC     BSF TXSTA, 5, ACCESS
381:           	RCSTAbits.CREN = 1;
089C  88AB     BSF RCSTA, 4, ACCESS
382:           	RCSTAbits.SPEN = 1;
089E  8EAB     BSF RCSTA, 7, ACCESS
383:           	TXSTAbits.SYNC = 0;
08A0  98AC     BCF TXSTA, 4, ACCESS
384:           	TXSTAbits.SYNC = 0;
08A2  98AC     BCF TXSTA, 4, ACCESS
385:           	TXSTAbits.BRGH = 0;
08A4  94AC     BCF TXSTA, 2, ACCESS
386:           	BAUDCTLbits.BRG16 = 1;
08A6  86AA     BSF BAUDCTL, 3, ACCESS
387:           	SPBRG = 129; /* 19200 baud */
08A8  0E81     MOVLW 0x81
08AA  6EAF     MOVWF SPBRG, ACCESS
388:           
389:           	/*      work int thread setup */
390:           	INTCONbits.TMR0IE = 1; // enable int
08AC  8AF2     BSF INTCON, 5, ACCESS
391:           	INTCON2bits.TMR0IP = 1; // make it high P
08AE  84F1     BSF INTCON2, 2, ACCESS
392:           
393:           	PIE1bits.TMR1IE = 1;
08B0  809D     BSF PIE1, 0, ACCESS
394:           	IPR1bits.TMR1IP = 1;
08B2  809F     BSF IPR1, 0, ACCESS
395:           
396:           	INTCONbits.INT0IE = 1; // enable RPM sensor input
08B4  88F2     BSF INTCON, 4, ACCESS
397:           	INTCON2bits.RBPU = 0; // enable weak pull-ups
08B6  9EF1     BCF INTCON2, 7, ACCESS
398:           
399:           	PIE1bits.RCIE = 1; // enable rs232 serial receive interrupts
08B8  8A9D     BSF PIE1, 5, ACCESS
400:           	IPR1bits.RCIP = 1;
08BA  8A9F     BSF IPR1, 5, ACCESS
401:           
402:           	init_rms_params();
08BC  EC4A     CALL 0x694, 0
08BE  F003     NOP
403:           	ringBufS_init(&ring_buf1);
08C0  0EA3     MOVLW 0xA3
08C2  0100     MOVLB 0x0
08C4  6FBE     MOVWF _this, BANKED
08C6  0E00     MOVLW 0x0
08C8  6FBF     MOVWF val, BANKED
08CA  EC03     CALL 0xC06, 0
08CC  F006     NOP
404:           
405:           	/* Enable all high priority interrupts */
406:           	INTCONbits.GIEH = 1;
08CE  8EF2     BSF INTCON, 7, ACCESS
407:           }
08D0  0012     RETURN 0
408:           
409:           uint8_t init_rms_params(void)
410:           {
411:           	V.spinning = FALSE;
0694  9003     BCF 0x3, 0, ACCESS
412:           	V.valid = TRUE;
0696  8001     BSF V, 0, ACCESS
413:           	V.comm = FALSE;
0698  9201     BCF V, 1, ACCESS
414:           	V.comm_state = 0;
069A  0E00     MOVLW 0x0
069C  6E02     MOVWF 0x2, ACCESS
415:           	V.line_num = 0;
069E  0EF3     MOVLW 0xF3
06A0  1603     ANDWF 0x3, F, ACCESS
416:           	V.comm_state = APP_STATE_INIT;
06A2  0E00     MOVLW 0x0
06A4  6E02     MOVWF 0x2, ACCESS
417:           	V.l_size = sizeof(L[0]);
06A6  0E00     MOVLW 0x0
06A8  6E0D     MOVWF 0xD, ACCESS
06AA  0E05     MOVLW 0x5
06AC  6E0C     MOVWF 0xC, ACCESS
418:           
419:           	USART_putsr("\r\nVersion ");
06AE  0E36     MOVLW 0x36
06B0  0100     MOVLB 0x0
06B2  6FB7     MOVWF value, BANKED
06B4  0E03     MOVLW 0x3
06B6  6FB8     MOVWF c, BANKED
06B8  ECDA     CALL 0xBB4, 0
06BA  F005     NOP
420:           	USART_putsr(versions);
06BC  0E16     MOVLW 0x16
06BE  0100     MOVLB 0x0
06C0  6FB7     MOVWF value, BANKED
06C2  0E03     MOVLW 0x3
06C4  6FB8     MOVWF c, BANKED
06C6  ECDA     CALL 0xBB4, 0
06C8  F005     NOP
421:           	USART_putsr(", ");
06CA  0E5E     MOVLW 0x5E
06CC  0100     MOVLB 0x0
06CE  6FB7     MOVWF value, BANKED
06D0  0E03     MOVLW 0x3
06D2  6FB8     MOVWF c, BANKED
06D4  ECDA     CALL 0xBB4, 0
06D6  F005     NOP
422:           	itoa(str, sizeof(L[0]), 10);
06D8  0E8B     MOVLW 0x8B
06DA  0100     MOVLB 0x0
06DC  6FC6     MOVWF buf, BANKED
06DE  0E00     MOVLW 0x0
06E0  6FC7     MOVWF 0xC7, BANKED
06E2  0E00     MOVLW 0x0
06E4  6FC9     MOVWF 0xC9, BANKED
06E6  0E05     MOVLW 0x5
06E8  6FC8     MOVWF val, BANKED
06EA  0E00     MOVLW 0x0
06EC  6FCB     MOVWF 0xCB, BANKED
06EE  0E0A     MOVLW 0xA
06F0  6FCA     MOVWF base, BANKED
06F2  EC60     CALL 0xAC0, 0
06F4  F005     NOP
423:           	USART_puts(str);
06F6  0E8B     MOVLW 0x8B
06F8  0100     MOVLB 0x0
06FA  6FB7     MOVWF value, BANKED
06FC  0E00     MOVLW 0x0
06FE  6FB8     MOVWF c, BANKED
0700  ECF0     CALL 0xBE0, 0
0702  F005     NOP
424:           	USART_putsr(", ");
0704  0E5E     MOVLW 0x5E
0706  0100     MOVLB 0x0
0708  6FB7     MOVWF value, BANKED
070A  0E03     MOVLW 0x3
070C  6FB8     MOVWF c, BANKED
070E  ECDA     CALL 0xBB4, 0
0710  F005     NOP
425:           	USART_putsr(build_date);
0712  0E01     MOVLW 0x1
0714  0100     MOVLB 0x0
0716  6FB7     MOVWF value, BANKED
0718  0E03     MOVLW 0x3
071A  6FB8     MOVWF c, BANKED
071C  ECDA     CALL 0xBB4, 0
071E  F005     NOP
426:           	USART_putsr(", ");
0720  0E5E     MOVLW 0x5E
0722  0100     MOVLB 0x0
0724  6FB7     MOVWF value, BANKED
0726  0E03     MOVLW 0x3
0728  6FB8     MOVWF c, BANKED
072A  ECDA     CALL 0xBB4, 0
072C  F005     NOP
427:           	USART_putsr(build_time);
072E  0E0D     MOVLW 0xD
0730  0100     MOVLB 0x0
0732  6FB7     MOVWF value, BANKED
0734  0E03     MOVLW 0x3
0736  6FB8     MOVWF c, BANKED
0738  ECDA     CALL 0xBB4, 0
073A  F005     NOP
428:           
429:           	L_ptr = &L[0];
073C  0E10     MOVLW 0x10
073E  6E0E     MOVWF L_ptr, ACCESS
0740  0E00     MOVLW 0x0
0742  6E0F     MOVWF 0xF, ACCESS
430:           	/* three line strobes in 3 16-bit timer values for spacing */
431:           	/* for an interrupt driven state machine */
432:           	L[0].strobe = 60000;
0744  0EEA     MOVLW 0xEA
0746  6E14     MOVWF 0x14, ACCESS
0748  0E60     MOVLW 0x60
074A  6E13     MOVWF 0x13, ACCESS
433:           	L[0].sequence.R = 1;
074C  8210     BSF L, 1, ACCESS
434:           	L[0].sequence.offset = strobe_up;
074E  0E00     MOVLW 0x0
0750  6E12     MOVWF 0x12, ACCESS
0752  0E3C     MOVLW 0x3C
0754  6E11     MOVWF 0x11, ACCESS
435:           
436:           	L[1].strobe = 50000; // 62000
0756  0EC3     MOVLW 0xC3
0758  6E19     MOVWF 0x19, ACCESS
075A  0E50     MOVLW 0x50
075C  6E18     MOVWF 0x18, ACCESS
437:           	L[1].sequence.G = 1;
075E  8415     BSF 0x15, 2, ACCESS
438:           	L[1].sequence.offset = strobe_down;
0760  0E01     MOVLW 0x1
0762  6E17     MOVWF 0x17, ACCESS
0764  0E68     MOVLW 0x68
0766  6E16     MOVWF 0x16, ACCESS
439:           
440:           	L[2].strobe = 40000;
0768  0E9C     MOVLW 0x9C
076A  6E1E     MOVWF 0x1E, ACCESS
076C  0E40     MOVLW 0x40
076E  6E1D     MOVWF 0x1D, ACCESS
441:           	L[2].sequence.B = 1;
0770  861A     BSF 0x1A, 3, ACCESS
442:           	L[2].sequence.offset = strobe_around;
0772  0E04     MOVLW 0x4
0774  6E1C     MOVWF 0x1C, ACCESS
0776  0E38     MOVLW 0x38
0778  6E1B     MOVWF 0x1B, ACCESS
443:           
444:           	L[3].strobe = 30000;
077A  0E75     MOVLW 0x75
077C  6E23     MOVWF 0x23, ACCESS
077E  0E30     MOVLW 0x30
0780  6E22     MOVWF 0x22, ACCESS
445:           	L[3].sequence.R = 1;
0782  821F     BSF 0x1F, 1, ACCESS
446:           	L[3].sequence.G = 1;
0784  841F     BSF 0x1F, 2, ACCESS
447:           	L[3].sequence.B = 1;
0786  861F     BSF 0x1F, 3, ACCESS
448:           	L[3].sequence.offset = 0;
0788  0E00     MOVLW 0x0
078A  6E21     MOVWF 0x21, ACCESS
078C  0E00     MOVLW 0x0
078E  6E20     MOVWF 0x20, ACCESS
449:           	L[3].sequence.end = 1;
0790  881F     BSF 0x1F, 4, ACCESS
450:           
451:           	L[strobe_max - 1].sequence.end = 1;
0792  885B     BSF 0x5B, 4, ACCESS
0794  0012     RETURN 0
452:           	return 0;
453:           }
454:           
455:           void main(void)
456:           {
457:           	init_rmsmon();
0C9E  EC20     CALL 0x840, 0
0CA0  F004     NOP
458:           
459:           	/* Loop forever */
460:           	while (TRUE) { // busy work
0CA6  D7FD     BRA 0xCA2
461:           		sw_work(); // run housekeeping
0CA2  ECB3     CALL 0x366, 0
0CA4  F001     NOP
0CA6  D7FD     BRA 0xCA2
462:           	}
463:           }
---  /opt/microchip/xc8/v1.44/sources/common/memset.c  --------------------------------------------------
1:             #include	<string.h>
2:             
3:             #ifdef _PIC16
4:             far void *
5:             memset(far void * p1, int c, register size_t n)
6:             #else /*  _PIC16 */
7:             void *
8:             memset(void * p1, int c, register size_t n)
9:             #endif /* _PIC16 */
10:            {
11:            
12:            #ifdef _PIC16
13:            	register far char *	p;
14:            #else /*  _PIC16 */
15:            	register char *		p;
16:            #endif /* _PIC16 */
17:            
18:            	p = p1;
0B84  C0B6     MOVFF __pcstackBANK0, p
0B86  F0BC     NOP
0B88  C0B7     MOVFF value, buf
0B8A  F0BD     NOP
19:            	while(n--)
0B8C  D009     BRA 0xBA0
0BA0  0100     MOVLB 0x0
20:            		*p++ = c;
0B8E  C0BC     MOVFF p, FSR2
0B90  FFD9     NOP
0B92  C0BD     MOVFF buf, FSR2H
0B94  FFDA     NOP
0B96  C0B8     MOVFF c, INDF2
0B98  FFDF     NOP
0B9A  0100     MOVLB 0x0
0B9C  4BBC     INFSNZ p, F, BANKED
0B9E  2BBD     INCF buf, F, BANKED
0BA0  0100     MOVLB 0x0
0BA2  07BA     DECF n, F, BANKED
0BA4  A0D8     BTFSS STATUS, 0, ACCESS
0BA6  07BB     DECF 0xBB, F, BANKED
0BA8  29BA     INCF n, W, BANKED
0BAA  E1F1     BNZ 0xB8E
0BAC  29BB     INCF 0xBB, W, BANKED
0BAE  B4D8     BTFSC STATUS, 2, ACCESS
0BB0  0012     RETURN 0
0BB2  D7ED     BRA 0xB8E
21:            	return p1;
22:            }
---  /opt/microchip/xc8/v1.44/sources/common/lwmod.c  ---------------------------------------------------
1:             // word unsigned modulus
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwmod(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwmod(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter;
12:            
13:            	if(divisor != 0) {
0B04  0100     MOVLB 0x0
0B06  51B8     MOVF c, W, BANKED
0B08  11B9     IORWF _this, W, BANKED
0B0A  B4D8     BTFSC STATUS, 2, ACCESS
0B0C  D018     BRA 0xB3E
14:            		counter = 1;
0B0E  0E01     MOVLW 0x1
0B10  6FBA     MOVWF n, BANKED
15:            		while((divisor & 0x8000) == 0) {
0B12  D004     BRA 0xB1C
16:            			divisor <<= 1;
0B14  90D8     BCF STATUS, 0, ACCESS
0B16  37B8     RLCF c, F, BANKED
0B18  37B9     RLCF _this, F, BANKED
17:            			counter++;
0B1A  2BBA     INCF n, F, BANKED
18:            		}
0B1C  AFB9     BTFSS _this, 7, BANKED
0B1E  D7FA     BRA 0xB14
19:            		do {
20:            			if(divisor <= dividend)
0B20  51B8     MOVF c, W, BANKED
0B22  5DB6     SUBWF __pcstackBANK0, W, BANKED
0B24  51B9     MOVF _this, W, BANKED
0B26  59B7     SUBWFB value, W, BANKED
0B28  A0D8     BTFSS STATUS, 0, ACCESS
0B2A  D004     BRA 0xB34
21:            				dividend -= divisor;
0B2C  51B8     MOVF c, W, BANKED
0B2E  5FB6     SUBWF __pcstackBANK0, F, BANKED
0B30  51B9     MOVF _this, W, BANKED
0B32  5BB7     SUBWFB value, F, BANKED
22:            			divisor >>= 1;
0B34  90D8     BCF STATUS, 0, ACCESS
0B36  33B9     RRCF _this, F, BANKED
0B38  33B8     RRCF c, F, BANKED
23:            		} while(--counter != 0);
0B3A  2FBA     DECFSZ n, F, BANKED
0B3C  D7F1     BRA 0xB20
24:            	}
25:            	return dividend;
0B3E  C0B6     MOVFF __pcstackBANK0, __pcstackBANK0
0B40  F0B6     NOP
0B42  C0B7     MOVFF value, value
0B44  F0B7     NOP
26:            }
0B46  0012     RETURN 0
---  /opt/microchip/xc8/v1.44/sources/common/lwdiv.c  ---------------------------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwdiv(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwdiv(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned int	quotient;
12:            	unsigned char	counter;
13:            
14:            	quotient = 0;
0A6C  0E00     MOVLW 0x0
0A6E  0100     MOVLB 0x0
0A70  6FBB     MOVWF 0xBB, BANKED
0A72  0E00     MOVLW 0x0
0A74  6FBA     MOVWF n, BANKED
15:            	if(divisor != 0) {
0A76  51B8     MOVF c, W, BANKED
0A78  11B9     IORWF _this, W, BANKED
0A7A  B4D8     BTFSC STATUS, 2, ACCESS
0A7C  D01C     BRA 0xAB6
16:            		counter = 1;
0A7E  0E01     MOVLW 0x1
0A80  6FBC     MOVWF p, BANKED
17:            		while((divisor & 0x8000) == 0) {
0A82  D004     BRA 0xA8C
18:            			divisor <<= 1;
0A84  90D8     BCF STATUS, 0, ACCESS
0A86  37B8     RLCF c, F, BANKED
0A88  37B9     RLCF _this, F, BANKED
19:            			counter++;
0A8A  2BBC     INCF p, F, BANKED
20:            		}
0A8C  AFB9     BTFSS _this, 7, BANKED
0A8E  D7FA     BRA 0xA84
21:            		do {
22:            			quotient <<= 1;
0A90  90D8     BCF STATUS, 0, ACCESS
0A92  37BA     RLCF n, F, BANKED
0A94  37BB     RLCF 0xBB, F, BANKED
23:            			if(divisor <= dividend) {
0A96  51B8     MOVF c, W, BANKED
0A98  5DB6     SUBWF __pcstackBANK0, W, BANKED
0A9A  51B9     MOVF _this, W, BANKED
0A9C  59B7     SUBWFB value, W, BANKED
0A9E  A0D8     BTFSS STATUS, 0, ACCESS
0AA0  D005     BRA 0xAAC
24:            				dividend -= divisor;
0AA2  51B8     MOVF c, W, BANKED
0AA4  5FB6     SUBWF __pcstackBANK0, F, BANKED
0AA6  51B9     MOVF _this, W, BANKED
0AA8  5BB7     SUBWFB value, F, BANKED
25:            				quotient |= 1;
0AAA  81BA     BSF n, 0, BANKED
26:            			}
27:            			divisor >>= 1;
0AAC  90D8     BCF STATUS, 0, ACCESS
0AAE  33B9     RRCF _this, F, BANKED
0AB0  33B8     RRCF c, F, BANKED
28:            		} while(--counter != 0);
0AB2  2FBC     DECFSZ p, F, BANKED
0AB4  D7ED     BRA 0xA90
29:            	}
30:            	return quotient;
0AB6  C0BA     MOVFF n, __pcstackBANK0
0AB8  F0B6     NOP
0ABA  C0BB     MOVFF 0xBB, value
0ABC  F0B7     NOP
31:            }
0ABE  0012     RETURN 0
---  /opt/microchip/xc8/v1.44/sources/common/itoa.c  ----------------------------------------------------
1:             #include	<stdlib.h>
2:             	
3:             char *
4:             itoa(char * buf, int val, int base)
5:             {
6:             	char *	cp = buf;
0AC0  C0C6     MOVFF buf, cp
0AC2  F0CC     NOP
0AC4  C0C7     MOVFF 0xC7, 0xCD
0AC6  F0CD     NOP
7:             
8:             	if(val < 0) {
0AC8  0100     MOVLB 0x0
0ACA  AFC9     BTFSS 0xC9, 7, BANKED
0ACC  D00C     BRA 0xAE6
9:             		*buf++ = '-';
0ACE  C0C6     MOVFF buf, FSR2
0AD0  FFD9     NOP
0AD2  C0C7     MOVFF 0xC7, FSR2H
0AD4  FFDA     NOP
0AD6  0E2D     MOVLW 0x2D
0AD8  6EDF     MOVWF INDF2, ACCESS
0ADA  4BC6     INFSNZ buf, F, BANKED
0ADC  2BC7     INCF 0xC7, F, BANKED
10:            		val = -val;
0ADE  6DC8     NEGF val, BANKED
0AE0  1FC9     COMF 0xC9, F, BANKED
0AE2  B0D8     BTFSC STATUS, 0, ACCESS
0AE4  2BC9     INCF 0xC9, F, BANKED
11:            	}
12:            	utoa(buf, val, base);
0AE6  C0C6     MOVFF buf, buf
0AE8  F0BD     NOP
0AEA  C0C7     MOVFF 0xC7, _this
0AEC  F0BE     NOP
0AEE  C0C8     MOVFF val, val
0AF0  F0BF     NOP
0AF2  C0C9     MOVFF 0xC9, clearBuffer
0AF4  F0C0     NOP
0AF6  C0CA     MOVFF base, base
0AF8  F0C1     NOP
0AFA  C0CB     MOVFF 0xCB, 0xC2
0AFC  F0C2     NOP
0AFE  ECCB     CALL 0x796, 0
0B00  F003     NOP
0B02  0012     RETURN 0
13:            	return cp;
14:            }
15:            
16:            char *
17:            utoa(char * buf, unsigned val, int base)
18:            {
19:            	unsigned	v;
20:            	char		c;
21:            
22:            	v = val;
0796  C0BF     MOVFF val, v
0798  F0C3     NOP
079A  C0C0     MOVFF clearBuffer, 0xC4
079C  F0C4     NOP
23:            	do {
24:            		v /= base;
079E  C0C3     MOVFF v, __pcstackBANK0
07A0  F0B6     NOP
07A2  C0C4     MOVFF 0xC4, value
07A4  F0B7     NOP
07A6  C0C1     MOVFF base, c
07A8  F0B8     NOP
07AA  C0C2     MOVFF 0xC2, _this
07AC  F0B9     NOP
07AE  EC36     CALL 0xA6C, 0
07B0  F005     NOP
07B2  C0B6     MOVFF __pcstackBANK0, v
07B4  F0C3     NOP
07B6  C0B7     MOVFF value, 0xC4
07B8  F0C4     NOP
25:            		buf++;
07BA  0100     MOVLB 0x0
07BC  4BBD     INFSNZ buf, F, BANKED
07BE  2BBE     INCF _this, F, BANKED
26:            	} while(v != 0);
07C0  51C3     MOVF v, W, BANKED
07C2  11C4     IORWF 0xC4, W, BANKED
07C4  A4D8     BTFSS STATUS, 2, ACCESS
07C6  D7EB     BRA 0x79E
27:            	*buf-- = 0;
07C8  C0BD     MOVFF buf, FSR2
07CA  FFD9     NOP
07CC  C0BE     MOVFF _this, FSR2H
07CE  FFDA     NOP
07D0  0E00     MOVLW 0x0
07D2  6EDF     MOVWF INDF2, ACCESS
07D4  07BD     DECF buf, F, BANKED
07D6  A0D8     BTFSS STATUS, 0, ACCESS
07D8  07BE     DECF _this, F, BANKED
28:            	do {
29:            		c = val % base;
07DA  C0BF     MOVFF val, __pcstackBANK0
07DC  F0B6     NOP
07DE  C0C0     MOVFF clearBuffer, value
07E0  F0B7     NOP
07E2  C0C1     MOVFF base, c
07E4  F0B8     NOP
07E6  C0C2     MOVFF 0xC2, _this
07E8  F0B9     NOP
07EA  EC82     CALL 0xB04, 0
07EC  F005     NOP
07EE  0100     MOVLB 0x0
07F0  51B6     MOVF __pcstackBANK0, W, BANKED
07F2  6FC5     MOVWF c, BANKED
30:            		val /= base;
07F4  C0BF     MOVFF val, __pcstackBANK0
07F6  F0B6     NOP
07F8  C0C0     MOVFF clearBuffer, value
07FA  F0B7     NOP
07FC  C0C1     MOVFF base, c
07FE  F0B8     NOP
0800  C0C2     MOVFF 0xC2, _this
0802  F0B9     NOP
0804  EC36     CALL 0xA6C, 0
0806  F005     NOP
0808  C0B6     MOVFF __pcstackBANK0, val
080A  F0BF     NOP
080C  C0B7     MOVFF value, clearBuffer
080E  F0C0     NOP
31:            		if(c >= 10)
0810  0E09     MOVLW 0x9
0812  0100     MOVLB 0x0
0814  65C5     CPFSGT c, BANKED
0816  D002     BRA 0x81C
32:            			c += 'A'-'0'-10;
0818  0E07     MOVLW 0x7
081A  27C5     ADDWF c, F, BANKED
33:            		c += '0';
081C  0E30     MOVLW 0x30
081E  27C5     ADDWF c, F, BANKED
34:            		*buf-- = c;
0820  C0BD     MOVFF buf, FSR2
0822  FFD9     NOP
0824  C0BE     MOVFF _this, FSR2H
0826  FFDA     NOP
0828  C0C5     MOVFF c, INDF2
082A  FFDF     NOP
082C  07BD     DECF buf, F, BANKED
082E  A0D8     BTFSS STATUS, 0, ACCESS
0830  07BE     DECF _this, F, BANKED
35:            	} while(val != 0);
0832  51BF     MOVF val, W, BANKED
0834  11C0     IORWF clearBuffer, W, BANKED
0836  A4D8     BTFSS STATUS, 2, ACCESS
0838  D7D0     BRA 0x7DA
36:            	return ++buf;
083A  4BBD     INFSNZ buf, F, BANKED
083C  2BBE     INCF _this, F, BANKED
083E  0012     RETURN 0
37:            }
38:            
