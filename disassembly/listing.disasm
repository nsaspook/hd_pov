Disassembly Listing for hd_pov
Generated From:
/root/hd_pov/dist/default/production/hd_pov.production.elf
Feb 9, 2018 2:10:04 PM

---  /root/hd_pov/ringbufs..c  --------------------------------------------------------------------------
1:             
2:             #include  <string.h>
3:             #include  <stdint.h>
4:             #include  "ringbufs.h"
5:             
6:             /*
7:              * general ring buffer functions from the net
8:              */
9:             uint8_t modulo_inc(const uint8_t value, const uint8_t modulus)
0D32  0100     MOVLB 0x0
0D34  6F95     MOVWF value, BANKED
10:            {
11:            	uint8_t my_value = value + 1;
0D36  0100     MOVLB 0x0
0D38  2995     INCF value, W, BANKED
0D3A  6F96     MOVWF divisor, BANKED
12:            	if (my_value >= modulus) {
0D3C  5194     MOVF dividend, W, BANKED
0D3E  5D96     SUBWF divisor, W, BANKED
0D40  A0D8     BTFSS STATUS, 0, ACCESS
0D42  D002     BRA 0xD48
13:            		my_value = 0;
0D44  0E00     MOVLW 0x0
0D46  6F96     MOVWF divisor, BANKED
14:            	}
15:            	return my_value;
0D48  5196     MOVF divisor, W, BANKED
0D4A  0012     RETURN 0
16:            }
17:            
18:            uint8_t modulo_inc_r(const uint8_t value, const uint8_t modulus)
0D4C  6E78     MOVWF value, ACCESS
19:            {
20:            	uint8_t my_value = value + 1;
0D4E  2878     INCF value, W, ACCESS
0D50  6E79     MOVWF my_value, ACCESS
21:            	if (my_value >= modulus) {
0D52  5077     MOVF __pcstackCOMRAM, W, ACCESS
0D54  5C79     SUBWF my_value, W, ACCESS
0D56  A0D8     BTFSS STATUS, 0, ACCESS
0D58  D002     BRA 0xD5E
22:            		my_value = 0;
0D5A  0E00     MOVLW 0x0
0D5C  6E79     MOVWF my_value, ACCESS
23:            	}
24:            	return my_value;
0D5E  5079     MOVF my_value, W, ACCESS
0D60  0012     RETURN 0
25:            }
26:            
27:            void ringBufS_init(ringBufS_t *_this)
28:            {
29:            	/*****
30:            	  The following clears:
31:            	    -> buf
32:            	    -> head
33:            	    -> tail
34:            	    -> count
35:            	  and sets head = tail
36:            	 ***/
37:            	memset(_this, 0, sizeof(*_this));
0CD8  C09C     MOVFF _this, dividend
0CDA  F094     NOP
0CDC  C09D     MOVFF val, value
0CDE  F095     NOP
0CE0  0E00     MOVLW 0x0
0CE2  0100     MOVLB 0x0
0CE4  6F97     MOVWF _this, BANKED
0CE6  0E00     MOVLW 0x0
0CE8  6F96     MOVWF divisor, BANKED
0CEA  0E00     MOVLW 0x0
0CEC  6F99     MOVWF 0x99, BANKED
0CEE  0E23     MOVLW 0x23
0CF0  6F98     MOVWF counter, BANKED
0CF2  EC18     CALL 0xC30, 0
0CF4  F006     NOP
38:            }
0CF6  0012     RETURN 0
39:            
40:            int8_t ringBufS_empty(ringBufS_t *_this)
41:            {
42:            	return(0 == _this->count);
0D16  0100     MOVLB 0x0
0D18  EE20     LFSR 2, 0x22
0D1A  F022     NOP
0D1C  5194     MOVF dividend, W, BANKED
0D1E  26D9     ADDWF FSR2, F, ACCESS
0D20  5195     MOVF value, W, BANKED
0D22  22DA     ADDWFC FSR2H, F, ACCESS
0D24  50DF     MOVF INDF2, W, ACCESS
0D26  A4D8     BTFSS STATUS, 2, ACCESS
0D28  D002     BRA 0xD2E
0D2A  0E01     MOVLW 0x1
0D2C  0012     RETURN 0
0D2E  0E00     MOVLW 0x0
0D30  0012     RETURN 0
43:            }
44:            
45:            int8_t ringBufS_full(ringBufS_t *_this)
46:            {
47:            	return(_this->count >= RBUF_SIZE);
0CF8  0100     MOVLB 0x0
0CFA  EE20     LFSR 2, 0x22
0CFC  F022     NOP
0CFE  5194     MOVF dividend, W, BANKED
0D00  26D9     ADDWF FSR2, F, ACCESS
0D02  5195     MOVF value, W, BANKED
0D04  22DA     ADDWFC FSR2H, F, ACCESS
0D06  0E20     MOVLW 0x20
0D08  60DF     CPFSLT INDF2, ACCESS
0D0A  D001     BRA 0xD0E
0D0C  D002     BRA 0xD12
0D0E  0E01     MOVLW 0x1
0D10  0012     RETURN 0
0D12  0E00     MOVLW 0x0
0D14  0012     RETURN 0
48:            }
49:            
50:            uint8_t ringBufS_get(ringBufS_t *_this)
51:            {
52:            	uint8_t c;
53:            	if (_this->count > 0) {
09E2  0100     MOVLB 0x0
09E4  EE20     LFSR 2, 0x22
09E6  F022     NOP
09E8  5197     MOVF _this, W, BANKED
09EA  26D9     ADDWF FSR2, F, ACCESS
09EC  5198     MOVF counter, W, BANKED
09EE  22DA     ADDWFC FSR2H, F, ACCESS
09F0  50DF     MOVF INDF2, W, ACCESS
09F2  B4D8     BTFSC STATUS, 2, ACCESS
09F4  D02D     BRA 0xA50
54:            		c = _this->buf[_this->tail];
09F6  EE20     LFSR 2, 0x21
09F8  F021     NOP
09FA  5197     MOVF _this, W, BANKED
09FC  26D9     ADDWF FSR2, F, ACCESS
09FE  5198     MOVF counter, W, BANKED
0A00  22DA     ADDWFC FSR2H, F, ACCESS
0A02  50DF     MOVF INDF2, W, ACCESS
0A04  6F99     MOVWF 0x99, BANKED
0A06  5199     MOVF 0x99, W, BANKED
0A08  0D01     MULLW 0x1
0A0A  50F3     MOVF PROD, W, ACCESS
0A0C  2597     ADDWF _this, W, BANKED
0A0E  6ED9     MOVWF FSR2, ACCESS
0A10  50F4     MOVF PRODH, W, ACCESS
0A12  2198     ADDWFC counter, W, BANKED
0A14  6EDA     MOVWF FSR2H, ACCESS
0A16  50DF     MOVF INDF2, W, ACCESS
0A18  6F9A     MOVWF counter, BANKED
55:            		_this->tail = modulo_inc(_this->tail, RBUF_SIZE);
0A1A  EE20     LFSR 2, 0x21
0A1C  F021     NOP
0A1E  5197     MOVF _this, W, BANKED
0A20  26D9     ADDWF FSR2, F, ACCESS
0A22  5198     MOVF counter, W, BANKED
0A24  22DA     ADDWFC FSR2H, F, ACCESS
0A26  0E20     MOVLW 0x20
0A28  6F94     MOVWF dividend, BANKED
0A2A  EE10     LFSR 1, 0x21
0A2C  F021     NOP
0A2E  5197     MOVF _this, W, BANKED
0A30  26E1     ADDWF FSR1, F, ACCESS
0A32  5198     MOVF counter, W, BANKED
0A34  22E2     ADDWFC FSR1H, F, ACCESS
0A36  50E7     MOVF INDF1, W, ACCESS
0A38  EC99     CALL 0xD32, 0
0A3A  F006     NOP
0A3C  6EDF     MOVWF INDF2, ACCESS
56:            		--_this->count;
0A3E  0100     MOVLB 0x0
0A40  EE20     LFSR 2, 0x22
0A42  F022     NOP
0A44  5197     MOVF _this, W, BANKED
0A46  26D9     ADDWF FSR2, F, ACCESS
0A48  5198     MOVF counter, W, BANKED
0A4A  22DA     ADDWFC FSR2H, F, ACCESS
0A4C  06DF     DECF INDF2, F, ACCESS
57:            	} else {
0A4E  D002     BRA 0xA54
58:            		c = 0; // return null with empty buffer
0A50  0E00     MOVLW 0x0
0A52  6F9A     MOVWF counter, BANKED
59:            	}
60:            	return(c);
0A54  519A     MOVF counter, W, BANKED
0A56  0012     RETURN 0
61:            }
62:            
63:            void ringBufS_put(ringBufS_t *_this, const uint8_t c)
64:            {
65:            	if (_this->count < RBUF_SIZE) {
0A58  EE20     LFSR 2, 0x22
0A5A  F022     NOP
0A5C  507A     MOVF _this, W, ACCESS
0A5E  26D9     ADDWF FSR2, F, ACCESS
0A60  507B     MOVF 0x7B, W, ACCESS
0A62  22DA     ADDWFC FSR2H, F, ACCESS
0A64  0E20     MOVLW 0x20
0A66  60DF     CPFSLT INDF2, ACCESS
0A68  0012     RETURN 0
66:            		_this->buf[_this->head] = c;
0A6A  EE20     LFSR 2, 0x20
0A6C  F020     NOP
0A6E  507A     MOVF _this, W, ACCESS
0A70  26D9     ADDWF FSR2, F, ACCESS
0A72  507B     MOVF 0x7B, W, ACCESS
0A74  22DA     ADDWFC FSR2H, F, ACCESS
0A76  50DF     MOVF INDF2, W, ACCESS
0A78  6E7D     MOVWF 0x7D, ACCESS
0A7A  507D     MOVF 0x7D, W, ACCESS
0A7C  0D01     MULLW 0x1
0A7E  50F3     MOVF PROD, W, ACCESS
0A80  247A     ADDWF _this, W, ACCESS
0A82  6ED9     MOVWF FSR2, ACCESS
0A84  50F4     MOVF PRODH, W, ACCESS
0A86  207B     ADDWFC 0x7B, W, ACCESS
0A88  6EDA     MOVWF FSR2H, ACCESS
0A8A  C07C     MOVFF c, INDF2
0A8C  FFDF     NOP
67:            		_this->head = modulo_inc_r(_this->head, RBUF_SIZE);
0A8E  EE20     LFSR 2, 0x20
0A90  F020     NOP
0A92  507A     MOVF _this, W, ACCESS
0A94  26D9     ADDWF FSR2, F, ACCESS
0A96  507B     MOVF 0x7B, W, ACCESS
0A98  22DA     ADDWFC FSR2H, F, ACCESS
0A9A  0E20     MOVLW 0x20
0A9C  6E77     MOVWF __pcstackCOMRAM, ACCESS
0A9E  EE10     LFSR 1, 0x20
0AA0  F020     NOP
0AA2  507A     MOVF _this, W, ACCESS
0AA4  26E1     ADDWF FSR1, F, ACCESS
0AA6  507B     MOVF 0x7B, W, ACCESS
0AA8  22E2     ADDWFC FSR1H, F, ACCESS
0AAA  50E7     MOVF INDF1, W, ACCESS
0AAC  ECA6     CALL 0xD4C, 0
0AAE  F006     NOP
0AB0  6EDF     MOVWF INDF2, ACCESS
68:            		++_this->count;
0AB2  EE20     LFSR 2, 0x22
0AB4  F022     NOP
0AB6  507A     MOVF _this, W, ACCESS
0AB8  26D9     ADDWF FSR2, F, ACCESS
0ABA  507B     MOVF 0x7B, W, ACCESS
0ABC  22DA     ADDWFC FSR2H, F, ACCESS
0ABE  2ADF     INCF INDF2, F, ACCESS
0AC0  0012     RETURN 0
69:            	}
70:            }
71:            
72:            void ringBufS_flush(ringBufS_t *_this, const int8_t clearBuffer)
73:            {
74:            	_this->count = 0;
0AC2  0100     MOVLB 0x0
0AC4  EE20     LFSR 2, 0x22
0AC6  F022     NOP
0AC8  519C     MOVF _this, W, BANKED
0ACA  26D9     ADDWF FSR2, F, ACCESS
0ACC  519D     MOVF val, W, BANKED
0ACE  22DA     ADDWFC FSR2H, F, ACCESS
0AD0  0E00     MOVLW 0x0
0AD2  6EDF     MOVWF INDF2, ACCESS
75:            	_this->head = 0;
0AD4  EE20     LFSR 2, 0x20
0AD6  F020     NOP
0AD8  519C     MOVF _this, W, BANKED
0ADA  26D9     ADDWF FSR2, F, ACCESS
0ADC  519D     MOVF val, W, BANKED
0ADE  22DA     ADDWFC FSR2H, F, ACCESS
0AE0  0E00     MOVLW 0x0
0AE2  6EDF     MOVWF INDF2, ACCESS
76:            	_this->tail = 0;
0AE4  EE20     LFSR 2, 0x21
0AE6  F021     NOP
0AE8  519C     MOVF _this, W, BANKED
0AEA  26D9     ADDWF FSR2, F, ACCESS
0AEC  519D     MOVF val, W, BANKED
0AEE  22DA     ADDWFC FSR2H, F, ACCESS
0AF0  0E00     MOVLW 0x0
0AF2  6EDF     MOVWF INDF2, ACCESS
77:            	if (clearBuffer) {
0AF4  519E     MOVF clearBuffer, W, BANKED
0AF6  B4D8     BTFSC STATUS, 2, ACCESS
0AF8  0012     RETURN 0
78:            		memset(_this->buf, 0, sizeof(_this->buf));
0AFA  C09C     MOVFF _this, dividend
0AFC  F094     NOP
0AFE  C09D     MOVFF val, value
0B00  F095     NOP
0B02  0E00     MOVLW 0x0
0B04  6F97     MOVWF _this, BANKED
0B06  0E00     MOVLW 0x0
0B08  6F96     MOVWF divisor, BANKED
0B0A  0E00     MOVLW 0x0
0B0C  6F99     MOVWF 0x99, BANKED
0B0E  0E20     MOVLW 0x20
0B10  6F98     MOVWF counter, BANKED
0B12  EC18     CALL 0xC30, 0
0B14  F006     NOP
0B16  0012     RETURN 0
79:            	}
80:            }
---  /root/hd_pov/pov_mon.c  ----------------------------------------------------------------------------
1:             // HD POV Version for XC8
2:             // PIC18F1320 Configuration Bit Settings 
3:             
4:             // CONFIG1H
5:             #pragma config OSC = HSPLL      // Oscillator Selection bits 40MHz fosc with PLL and 10MHz clock input
6:             #pragma config FSCM = ON        // Fail-Safe Clock Monitor Enable bit (Fail-Safe Clock Monitor enabled)
7:             #pragma config IESO = ON        // Internal External Switchover bit (Internal External Switchover mode enabled)
8:             
9:             // CONFIG2L
10:            #pragma config PWRT = OFF       // Power-up Timer Enable bit (PWRT disabled)
11:            #pragma config BOR = ON         // Brown-out Reset Enable bit (Brown-out Reset enabled)
12:            // BORV = No Setting
13:            
14:            // CONFIG2H
15:            #pragma config WDT = OFF        // Watchdog Timer Enable bit 
16:            #pragma config WDTPS = 4096    // Watchdog Timer Postscale Select bits 
17:            
18:            // CONFIG3H
19:            #pragma config MCLRE = ON       // MCLR Pin Enable bit (MCLR pin enabled, RA5 input pin disabled)
20:            
21:            // CONFIG4L
22:            #pragma config STVR = ON        // Stack Full/Underflow Reset Enable bit (Stack full/underflow will cause Reset)
23:            #pragma config LVP = OFF        // Low-Voltage ICSP Enable bit (Low-Voltage ICSP disabled)
24:            
25:            // CONFIG5L
26:            #pragma config CP0 = ON        // Code Protection bit (Block 0 (00200-000FFFh) not code-protected)
27:            #pragma config CP1 = ON        // Code Protection bit (Block 1 (001000-001FFFh) not code-protected)
28:            
29:            // CONFIG5H
30:            #pragma config CPB = OFF        // Boot Block Code Protection bit (Boot Block (000000-0001FFh) not code-protected)
31:            #pragma config CPD = OFF        // Data EEPROM Code Protection bit (Data EEPROM not code-protected)
32:            
33:            // CONFIG6L
34:            #pragma config WRT0 = OFF       // Write Protection bit (Block 0 (00200-000FFFh) not write-protected)
35:            #pragma config WRT1 = OFF       // Write Protection bit (Block 1 (001000-001FFFh) not write-protected)
36:            
37:            // CONFIG6H
38:            #pragma config WRTC = OFF       // Configuration Register Write Protection bit (Configuration registers (300000-3000FFh) not write-protected)
39:            #pragma config WRTB = OFF       // Boot Block Write Protection bit (Boot Block (000000-0001FFh) not write-protected)
40:            #pragma config WRTD = OFF       // Data EEPROM Write Protection bit (Data EEPROM not write-protected)
41:            
42:            // CONFIG7L
43:            #pragma config EBTR0 = OFF      // Table Read Protection bit (Block 0 (00200-000FFFh) not protected from table reads executed in other blocks)
44:            #pragma config EBTR1 = OFF      // Table Read Protection bit (Block 1 (001000-001FFFh) not protected from table reads executed in other blocks)
45:            
46:            // CONFIG7H
47:            #pragma config EBTRB = OFF      // Boot Block Table Read Protection bit (Boot Block (000000-0001FFh) not protected from table reads executed in other blocks)
48:            
49:            
50:            /*
51:             * Driver for hard-drive strobe for POV demo
52:             * Versions
53:             * 1.0 RGB support
54:             * 1.1 multi sequence support
55:             * 1.2 cleanup state machine and data logic
56:             * 1.3 add routines for remote configuration of strobes
57:             * 1.4 add buffering for rs232
58:             * 1.5 cleanup remote data handling
59:             * 1.6 Beta version
60:             * 1.7 release cleanup
61:             */
62:            
63:            #include  <xc.h>
64:            #include <stdlib.h>
65:            #include <stdio.h>
66:            #include <stdint.h>
67:            #include <stdbool.h>
68:            #include "pov_mon.h"
69:            #include <string.h>
70:            #include "ringbufs.h"
71:            
72:            int16_t sw_work(void);
73:            void init_povmon(void);
74:            uint8_t init_hov_params(void);
75:            
76:            near struct V_data V = {0};
77:            near struct L_data L[strobe_max] = {0}, *L_ptr;
78:            
79:            /* RS232 command buffer */
80:            struct ringBufS_t ring_buf1;
81:            
82:            const uint8_t build_date[] = __DATE__, build_time[] = __TIME__, versions[] = "1.7";
83:            const uint16_t TIMEROFFSET = 18000, TIMERDEF = 60000;
84:            
85:            void interrupt high_priority tm_handler(void) // timer/serial functions are handled here
86:            {
87:            	LED1 = 1;
0052  8689     BSF LATA, 3, ACCESS
88:            	// line rotation sequencer
89:            	if (INTCONbits.INT0IF) { // Hall effect index signal, start of rotation
0054  A2F2     BTFSS INTCON, 1, ACCESS
0056  D0A8     BRA 0x1A8
90:            		INTCONbits.INT0IF = false;
0058  92F2     BCF INTCON, 1, ACCESS
91:            		RPMLED = (uint8_t)!RPMLED;
005A  BA8A     BTFSC LATB, 5, ACCESS
005C  D004     BRA 0x66
005E  0100     MOVLB 0x0
0060  6B80     CLRF __pcstackBANK0, BANKED
0062  2B80     INCF __pcstackBANK0, F, BANKED
0064  D002     BRA 0x6A
0066  0100     MOVLB 0x0
0068  6B80     CLRF __pcstackBANK0, BANKED
006A  3B80     SWAPF __pcstackBANK0, F, BANKED
006C  4780     RLNCF __pcstackBANK0, F, BANKED
006E  508A     MOVF LATB, W, ACCESS
0070  1980     XORWF __pcstackBANK0, W, BANKED
0072  0BDF     ANDLW 0xDF
0074  1980     XORWF __pcstackBANK0, W, BANKED
0076  6E8A     MOVWF LATB, ACCESS
92:            		if (V.l_state == ISR_STATE_LINE) { // off state too long for full rotation, hall signal while in state
0078  0452     DECF 0x52, W, ACCESS
007A  A4D8     BTFSS STATUS, 2, ACCESS
007C  D004     BRA 0x86
93:            			V.l_full += strobe_adjust; // off state lower limit adjustments for smooth strobe rotation
007E  0E0B     MOVLW 0xB
0080  265B     ADDWF 0x5B, F, ACCESS
0082  0E00     MOVLW 0x0
0084  225C     ADDWFC 0x5C, F, ACCESS
94:            		}
95:            		V.l_state = ISR_STATE_FLAG; // restart lamp flashing sequence, off time
0086  0E00     MOVLW 0x0
0088  6E52     MOVWF 0x52, ACCESS
96:            
97:            		L_ptr = &L[V.line_num]; // select line strobe data
008A  3053     RRCF 0x53, W, ACCESS
008C  0B03     ANDLW 0x3
008E  6F80     MOVWF __pcstackBANK0, BANKED
0090  5180     MOVF __pcstackBANK0, W, BANKED
0092  0D05     MULLW 0x5
0094  0E01     MOVLW 0x1
0096  24F3     ADDWF PROD, W, ACCESS
0098  6FBA     MOVWF L_ptr, BANKED
009A  0E00     MOVLW 0x0
009C  20F4     ADDWFC PRODH, W, ACCESS
009E  6FBB     MOVWF 0xBB, BANKED
98:            		V.rotations++;
00A0  4A57     INFSNZ 0x57, F, ACCESS
00A2  2A58     INCF 0x58, F, ACCESS
99:            
100:           		/* limit rotational timer values during offsets */
101:           		switch (L_ptr->sequence.down) {
00A4  D056     BRA 0x152
0152  C0BA     MOVFF L_ptr, FSR2
0154  FFD9     NOP
0156  C0BB     MOVFF 0xBB, FSR2H
0158  FFDA     NOP
015A  A0DF     BTFSS INDF2, 0, ACCESS
015C  D002     BRA 0x162
015E  0E01     MOVLW 0x1
0160  D001     BRA 0x164
0162  0E00     MOVLW 0x0
0164  0A00     XORLW 0x0
0166  B4D8     BTFSC STATUS, 2, ACCESS
0168  D79E     BRA 0xA6
016A  0A01     XORLW 0x1
016C  D7C7     BRA 0xFC
102:           		case false:
103:           			L_ptr->strobe += L_ptr->sequence.offset;
00A6  EE20     LFSR 2, 0x1
00A8  F001     NOP
00AA  51BA     MOVF L_ptr, W, BANKED
00AC  26D9     ADDWF FSR2, F, ACCESS
00AE  51BB     MOVF 0xBB, W, BANKED
00B0  22DA     ADDWFC FSR2H, F, ACCESS
00B2  CFDE     MOVFF POSTINC2, __pcstackBANK0
00B4  F080     NOP
00B6  CFDD     MOVFF POSTDEC2, 0x81
00B8  F081     NOP
00BA  EE20     LFSR 2, 0x3
00BC  F003     NOP
00BE  51BA     MOVF L_ptr, W, BANKED
00C0  26D9     ADDWF FSR2, F, ACCESS
00C2  51BB     MOVF 0xBB, W, BANKED
00C4  22DA     ADDWFC FSR2H, F, ACCESS
00C6  5180     MOVF __pcstackBANK0, W, BANKED
00C8  26DE     ADDWF POSTINC2, F, ACCESS
00CA  5181     MOVF 0x81, W, BANKED
00CC  22DD     ADDWFC POSTDEC2, F, ACCESS
104:           			if (L_ptr->strobe < V.l_full)
00CE  EE20     LFSR 2, 0x3
00D0  F003     NOP
00D2  51BA     MOVF L_ptr, W, BANKED
00D4  26D9     ADDWF FSR2, F, ACCESS
00D6  51BB     MOVF 0xBB, W, BANKED
00D8  22DA     ADDWFC FSR2H, F, ACCESS
00DA  505B     MOVF 0x5B, W, ACCESS
00DC  5CDE     SUBWF POSTINC2, W, ACCESS
00DE  505C     MOVF 0x5C, W, ACCESS
00E0  58DE     SUBWFB POSTINC2, W, ACCESS
00E2  B0D8     BTFSC STATUS, 0, ACCESS
00E4  D044     BRA 0x16E
105:           				L_ptr->strobe = V.l_full; // set to sliding lower limit
00E6  EE20     LFSR 2, 0x3
00E8  F003     NOP
00EA  51BA     MOVF L_ptr, W, BANKED
00EC  26D9     ADDWF FSR2, F, ACCESS
00EE  51BB     MOVF 0xBB, W, BANKED
00F0  22DA     ADDWFC FSR2H, F, ACCESS
00F2  C05B     MOVFF 0x5B, POSTINC2
00F4  FFDE     NOP
00F6  C05C     MOVFF 0x5C, POSTDEC2
00F8  FFDD     NOP
106:           			break;
00FA  D039     BRA 0x16E
107:           		case true:
108:           			L_ptr->strobe -= L_ptr->sequence.offset;
109:           			if (L_ptr->strobe < V.l_full)
110:           				L_ptr->strobe = strobe_limit_h;
111:           			break;
112:           
113:           		default:
114:           			L_ptr->strobe -= L_ptr->sequence.offset;
00FC  EE20     LFSR 2, 0x1
00FE  F001     NOP
0100  51BA     MOVF L_ptr, W, BANKED
0102  26D9     ADDWF FSR2, F, ACCESS
0104  51BB     MOVF 0xBB, W, BANKED
0106  22DA     ADDWFC FSR2H, F, ACCESS
0108  CFDE     MOVFF POSTINC2, __pcstackBANK0
010A  F080     NOP
010C  CFDD     MOVFF POSTDEC2, 0x81
010E  F081     NOP
0110  EE20     LFSR 2, 0x3
0112  F003     NOP
0114  51BA     MOVF L_ptr, W, BANKED
0116  26D9     ADDWF FSR2, F, ACCESS
0118  51BB     MOVF 0xBB, W, BANKED
011A  22DA     ADDWFC FSR2H, F, ACCESS
011C  5180     MOVF __pcstackBANK0, W, BANKED
011E  5EDE     SUBWF POSTINC2, F, ACCESS
0120  5181     MOVF 0x81, W, BANKED
0122  5ADD     SUBWFB POSTDEC2, F, ACCESS
115:           			if (L_ptr->strobe < V.l_full)
0124  EE20     LFSR 2, 0x3
0126  F003     NOP
0128  51BA     MOVF L_ptr, W, BANKED
012A  26D9     ADDWF FSR2, F, ACCESS
012C  51BB     MOVF 0xBB, W, BANKED
012E  22DA     ADDWFC FSR2H, F, ACCESS
0130  505B     MOVF 0x5B, W, ACCESS
0132  5CDE     SUBWF POSTINC2, W, ACCESS
0134  505C     MOVF 0x5C, W, ACCESS
0136  58DE     SUBWFB POSTINC2, W, ACCESS
0138  B0D8     BTFSC STATUS, 0, ACCESS
013A  D019     BRA 0x16E
116:           				L_ptr->strobe = strobe_limit_h;
013C  EE20     LFSR 2, 0x3
013E  F003     NOP
0140  51BA     MOVF L_ptr, W, BANKED
0142  26D9     ADDWF FSR2, F, ACCESS
0144  51BB     MOVF 0xBB, W, BANKED
0146  22DA     ADDWFC FSR2H, F, ACCESS
0148  0EFE     MOVLW 0xFE
014A  6EDE     MOVWF POSTINC2, ACCESS
014C  0EFF     MOVLW 0xFF
014E  6EDD     MOVWF POSTDEC2, ACCESS
117:           			break;
118:           		}
0150  D00E     BRA 0x16E
119:           		V.line_num++;
016E  0E01     MOVLW 0x1
0170  6F80     MOVWF __pcstackBANK0, BANKED
0172  3053     RRCF 0x53, W, ACCESS
0174  0B03     ANDLW 0x3
0176  6F81     MOVWF 0x81, BANKED
0178  5180     MOVF __pcstackBANK0, W, BANKED
017A  2781     ADDWF 0x81, F, BANKED
017C  3781     RLCF 0x81, F, BANKED
017E  5053     MOVF 0x53, W, ACCESS
0180  1981     XORWF 0x81, W, BANKED
0182  0BF9     ANDLW 0xF9
0184  1981     XORWF 0x81, W, BANKED
0186  6E53     MOVWF 0x53, ACCESS
120:           		if (L_ptr->sequence.end || (V.line_num >= strobe_max)) { // rollover for sequence patterns
0188  C0BA     MOVFF L_ptr, FSR2
018A  FFD9     NOP
018C  C0BB     MOVFF 0xBB, FSR2H
018E  FFDA     NOP
0190  B8DF     BTFSC INDF2, 4, ACCESS
0192  D006     BRA 0x1A0
0194  3053     RRCF 0x53, W, ACCESS
0196  0B03     ANDLW 0x3
0198  6F80     MOVWF __pcstackBANK0, BANKED
019A  0E0F     MOVLW 0xF
019C  6580     CPFSGT __pcstackBANK0, BANKED
019E  D004     BRA 0x1A8
121:           			V.line_num = 0;
01A0  0EF9     MOVLW 0xF9
01A2  1653     ANDWF 0x53, F, ACCESS
122:           			V.sequences++;
01A4  4A59     INFSNZ 0x59, F, ACCESS
01A6  2A5A     INCF 0x5A, F, ACCESS
123:           		}
124:           	}
125:           
126:           	// line RGB pulsing state machine
127:           	if (PIR1bits.TMR1IF || (V.l_state == ISR_STATE_FLAG)) { // Timer1 int handler, for strobe rotation timing
01A8  B09E     BTFSC PIR1, 0, ACCESS
01AA  D003     BRA 0x1B2
01AC  5052     MOVF 0x52, W, ACCESS
01AE  A4D8     BTFSS STATUS, 2, ACCESS
01B0  D04E     BRA 0x24E
128:           		PIR1bits.TMR1IF = false;
01B2  909E     BCF PIR1, 0, ACCESS
129:           
130:           		switch (V.l_state) {
01B4  D043     BRA 0x23C
023C  5052     MOVF 0x52, W, ACCESS
023E  0A00     XORLW 0x0
0240  B4D8     BTFSC STATUS, 2, ACCESS
0242  D7B9     BRA 0x1B6
0244  0A01     XORLW 0x1
0246  B4D8     BTFSC STATUS, 2, ACCESS
0248  D7D4     BRA 0x1F2
024A  0A03     XORLW 0x3
024C  D7F2     BRA 0x232
131:           		case ISR_STATE_FLAG:
132:           			WRITETIMER1(L_ptr->strobe); // strobe positioning during rotation
01B6  0100     MOVLB 0x0
01B8  EE20     LFSR 2, 0x3
01BA  F003     NOP
01BC  51BA     MOVF L_ptr, W, BANKED
01BE  26D9     ADDWF FSR2, F, ACCESS
01C0  51BB     MOVF 0xBB, W, BANKED
01C2  22DA     ADDWFC FSR2H, F, ACCESS
01C4  CFDE     MOVFF POSTINC2, __pcstackBANK0
01C6  F080     NOP
01C8  CFDD     MOVFF POSTDEC2, 0x81
01CA  F081     NOP
01CC  C081     MOVFF 0x81, __pcstackBANK0
01CE  F080     NOP
01D0  6B81     CLRF 0x81, BANKED
01D2  5180     MOVF __pcstackBANK0, W, BANKED
01D4  6ECF     MOVWF TMR1H, ACCESS
01D6  EE20     LFSR 2, 0x3
01D8  F003     NOP
01DA  51BA     MOVF L_ptr, W, BANKED
01DC  26D9     ADDWF FSR2, F, ACCESS
01DE  51BB     MOVF 0xBB, W, BANKED
01E0  22DA     ADDWFC FSR2H, F, ACCESS
01E2  50DF     MOVF INDF2, W, ACCESS
01E4  6ECE     MOVWF TMR1, ACCESS
133:           			T1CONbits.TMR1ON = 1;
01E6  80CD     BSF T1CON, 0, ACCESS
134:           			G_OUT = 0;
01E8  9089     BCF LATA, 0, ACCESS
135:           			R_OUT = 0;
01EA  9289     BCF LATA, 1, ACCESS
136:           			B_OUT = 0;
01EC  9489     BCF LATA, 2, ACCESS
137:           			V.l_state = ISR_STATE_LINE; // off time after index to start time
01EE  0E01     MOVLW 0x1
01F0  D01E     BRA 0x22E
138:           			break;
139:           		case ISR_STATE_LINE:
140:           			WRITETIMER1(V.l_width);
01F2  505E     MOVF 0x5E, W, ACCESS
01F4  6ECF     MOVWF TMR1H, ACCESS
01F6  C05D     MOVFF 0x5D, TMR1
01F8  FFCE     NOP
141:           			if (!L_ptr->sequence.skip) {
01FA  C0BA     MOVFF L_ptr, FSR2
01FC  FFD9     NOP
01FE  C0BB     MOVFF 0xBB, FSR2H
0200  FFDA     NOP
0202  0100     MOVLB 0x0
0204  BADF     BTFSC INDF2, 5, ACCESS
0206  D012     BRA 0x22C
142:           				if (L_ptr->sequence.R)
0208  C0BA     MOVFF L_ptr, FSR2
020A  FFD9     NOP
020C  C0BB     MOVFF 0xBB, FSR2H
020E  FFDA     NOP
0210  B2DF     BTFSC INDF2, 1, ACCESS
143:           					R_OUT = 1;
0212  8289     BSF LATA, 1, ACCESS
144:           				if (L_ptr->sequence.G)
0214  C0BA     MOVFF L_ptr, FSR2
0216  FFD9     NOP
0218  C0BB     MOVFF 0xBB, FSR2H
021A  FFDA     NOP
021C  B4DF     BTFSC INDF2, 2, ACCESS
145:           					G_OUT = 1;
021E  8089     BSF LATA, 0, ACCESS
146:           				if (L_ptr->sequence.B)
0220  C0BA     MOVFF L_ptr, FSR2
0222  FFD9     NOP
0224  C0BB     MOVFF 0xBB, FSR2H
0226  FFDA     NOP
0228  B6DF     BTFSC INDF2, 3, ACCESS
147:           					B_OUT = 1;
022A  8489     BSF LATA, 2, ACCESS
148:           			}
149:           
150:           			V.l_state = ISR_STATE_WAIT; // on start time duration for strobe pulse
022C  0E02     MOVLW 0x2
022E  6E52     MOVWF 0x52, ACCESS
151:           			break;
0230  D00E     BRA 0x24E
152:           		case ISR_STATE_WAIT: // waiting for next HALL sensor pulse
153:           		default:
154:           			T1CONbits.TMR1ON = 0; // idle timer
0232  90CD     BCF T1CON, 0, ACCESS
155:           			G_OUT = 0; // blank RGB
0234  9089     BCF LATA, 0, ACCESS
156:           			R_OUT = 0;
0236  9289     BCF LATA, 1, ACCESS
157:           			B_OUT = 0;
0238  9489     BCF LATA, 2, ACCESS
158:           			break;
159:           		}
023A  D009     BRA 0x24E
160:           	}
161:           
162:           	// remote command data buffer
163:           	if (PIR1bits.RCIF) { // is data from RS-232 port
024E  AA9E     BTFSS PIR1, 5, ACCESS
0250  D00E     BRA 0x26E
164:           		V.rx_data = RCREG; // save in state machine register
0252  CFAE     MOVFF RCREG, 0x54
0254  F054     NOP
165:           		if (RCSTAbits.OERR) {
0256  A2AB     BTFSS RCSTA, 1, ACCESS
0258  D002     BRA 0x25E
166:           			RCSTAbits.CREN = 0; // clear overrun
025A  98AB     BCF RCSTA, 4, ACCESS
167:           			RCSTAbits.CREN = 1; // re-enable
025C  88AB     BSF RCSTA, 4, ACCESS
168:           		}
169:           		ringBufS_put(&ring_buf1, V.rx_data); // buffer RS232 data
025E  0EBF     MOVLW 0xBF
0260  6E7A     MOVWF _this, ACCESS
0262  0E00     MOVLW 0x0
0264  6E7B     MOVWF 0x7B, ACCESS
0266  C054     MOVFF 0x54, c
0268  F07C     NOP
026A  EC2C     CALL 0xA58, 0
026C  F005     NOP
170:           	}
171:           
172:           	// check timer0 for blinker led
173:           	if (INTCONbits.TMR0IF) {
026E  A4F2     BTFSS INTCON, 2, ACCESS
0270  D026     BRA 0x2BE
174:           		INTCONbits.TMR0IF = false;
0272  94F2     BCF INTCON, 2, ACCESS
175:           		WRITETIMER0(TIMEROFFSET);
0274  0E13     MOVLW 0x13
0276  6EF6     MOVWF TBLPTR, ACCESS
0278  0E03     MOVLW 0x3
027A  6EF7     MOVWF TBLPTRH, ACCESS
027C  0009     TBLRD*+
027E  CFF5     MOVFF TABLAT, __pcstackBANK0
0280  F080     NOP
0282  0009     TBLRD*+
0284  CFF5     MOVFF TABLAT, 0x81
0286  F081     NOP
0288  C081     MOVFF 0x81, __pcstackBANK0
028A  F080     NOP
028C  0100     MOVLB 0x0
028E  6B81     CLRF 0x81, BANKED
0290  5180     MOVF __pcstackBANK0, W, BANKED
0292  6ED7     MOVWF TMR0H, ACCESS
0294  0E13     MOVLW 0x13
0296  6EF6     MOVWF TBLPTR, ACCESS
0298  0E03     MOVLW 0x3
029A  6EF7     MOVWF TBLPTRH, ACCESS
029C  0008     TBLRD*
029E  CFF5     MOVFF TABLAT, TMR0
02A0  FFD6     NOP
176:           		LED5 = (uint8_t)!LED5; // active LED blinker
02A2  BE8A     BTFSC LATB, 7, ACCESS
02A4  D003     BRA 0x2AC
02A6  6B80     CLRF __pcstackBANK0, BANKED
02A8  2B80     INCF __pcstackBANK0, F, BANKED
02AA  D002     BRA 0x2B0
02AC  0100     MOVLB 0x0
02AE  6B80     CLRF __pcstackBANK0, BANKED
02B0  3380     RRCF __pcstackBANK0, F, BANKED
02B2  3380     RRCF __pcstackBANK0, F, BANKED
02B4  508A     MOVF LATB, W, ACCESS
02B6  1980     XORWF __pcstackBANK0, W, BANKED
02B8  0B7F     ANDLW 0x7F
02BA  1980     XORWF __pcstackBANK0, W, BANKED
02BC  6E8A     MOVWF LATB, ACCESS
177:           	}
178:           	LED1 = 0;
02BE  9689     BCF LATA, 3, ACCESS
179:           }
02C0  C093     MOVFF 0x93, 0x81
180:           
181:           void USART_putc(uint8_t c)
0D62  0100     MOVLB 0x0
0D64  6F94     MOVWF dividend, BANKED
182:           {
183:           	while (!TXSTAbits.TRMT);
0D66  A2AC     BTFSS TXSTA, 1, ACCESS
0D68  D7FE     BRA 0xD66
184:           	TXREG = c;
0D6A  C094     MOVFF dividend, TXREG
0D6C  FFAD     NOP
185:           }
0008  827E     BSF btemp, 1, ACCESS
000A  CFFA     MOVFF PCLATH, 0x82
000C  F082     NOP
000E  CFFB     MOVFF PCLATU, 0x83
0010  F083     NOP
0012  CFE9     MOVFF FSR0, 0x84
0014  F084     NOP
0016  CFEA     MOVFF FSR0H, 0x85
0018  F085     NOP
001A  CFE1     MOVFF FSR1, 0x86
001C  F086     NOP
001E  CFE2     MOVFF FSR1H, 0x87
0020  F087     NOP
0022  CFD9     MOVFF FSR2, 0x88
0024  F088     NOP
0026  CFDA     MOVFF FSR2H, 0x89
0028  F089     NOP
002A  CFF3     MOVFF PROD, 0x8A
002C  F08A     NOP
002E  CFF4     MOVFF PRODH, 0x8B
0030  F08B     NOP
0032  CFF6     MOVFF TBLPTR, 0x8C
0034  F08C     NOP
0036  CFF7     MOVFF TBLPTRH, 0x8D
0038  F08D     NOP
003A  CFF8     MOVFF TBLPTRU, 0x8E
003C  F08E     NOP
003E  CFF5     MOVFF TABLAT, 0x8F
0040  F08F     NOP
0042  C07E     MOVFF btemp, 0x90
0044  F090     NOP
0046  C07F     MOVFF 0x7F, 0x91
0048  F091     NOP
004A  C080     MOVFF __pcstackBANK0, 0x92
004C  F092     NOP
004E  C081     MOVFF 0x81, 0x93
0050  F093     NOP
0D6E  0012     RETURN 0
186:           
187:           void USART_puts(uint8_t *s)
188:           {
189:           	while (*s) {
0CB2  D00A     BRA 0xCC8
190:           		USART_putc(*s);
0CB4  C095     MOVFF value, FSR2
0CB6  FFD9     NOP
0CB8  C096     MOVFF divisor, FSR2H
0CBA  FFDA     NOP
0CBC  50DF     MOVF INDF2, W, ACCESS
0CBE  ECB1     CALL 0xD62, 0
0CC0  F006     NOP
191:           		s++;
0CC2  0100     MOVLB 0x0
0CC4  4B95     INFSNZ value, F, BANKED
0CC6  2B96     INCF divisor, F, BANKED
192:           	}
0CC8  C095     MOVFF value, FSR2
0CCA  FFD9     NOP
0CCC  C096     MOVFF divisor, FSR2H
0CCE  FFDA     NOP
0CD0  50DF     MOVF INDF2, W, ACCESS
0CD2  B4D8     BTFSC STATUS, 2, ACCESS
0CD4  0012     RETURN 0
0CD6  D7EE     BRA 0xCB4
193:           }
194:           
195:           void USART_putsr(const uint8_t *s)
196:           {
197:           	while (*s) {
0C60  D00B     BRA 0xC78
198:           		USART_putc(*s);
0C62  C095     MOVFF value, TBLPTR
0C64  FFF6     NOP
0C66  C096     MOVFF divisor, TBLPTRH
0C68  FFF7     NOP
0C6A  0008     TBLRD*
0C6C  50F5     MOVF TABLAT, W, ACCESS
0C6E  ECB1     CALL 0xD62, 0
0C70  F006     NOP
199:           		s++;
0C72  0100     MOVLB 0x0
0C74  4B95     INFSNZ value, F, BANKED
0C76  2B96     INCF divisor, F, BANKED
200:           	}
0C78  C095     MOVFF value, TBLPTR
0C7A  FFF6     NOP
0C7C  C096     MOVFF divisor, TBLPTRH
0C7E  FFF7     NOP
0C80  0008     TBLRD*
0C82  50F5     MOVF TABLAT, W, ACCESS
0C84  0900     IORLW 0x0
0C86  B4D8     BTFSC STATUS, 2, ACCESS
0C88  0012     RETURN 0
0C8A  D7EB     BRA 0xC62
201:           }
202:           
203:           void puts_ok(uint16_t size)
204:           {
205:           	itoa(V.str, size, 10);
0BF4  0E5F     MOVLW 0x5F
0BF6  0100     MOVLB 0x0
0BF8  6FA4     MOVWF buf, BANKED
0BFA  0E00     MOVLW 0x0
0BFC  6FA5     MOVWF 0xA5, BANKED
0BFE  C0AC     MOVFF size, val
0C00  F0A6     NOP
0C02  C0AD     MOVFF 0xAD, 0xA7
0C04  F0A7     NOP
0C06  0E00     MOVLW 0x0
0C08  6FA9     MOVWF 0xA9, BANKED
0C0A  0E0A     MOVLW 0xA
0C0C  6FA8     MOVWF base, BANKED
0C0E  ECB6     CALL 0xB6C, 0
0C10  F005     NOP
206:           	USART_putsr("\r\n OK");
0C12  0E7B     MOVLW 0x7B
0C14  0100     MOVLB 0x0
0C16  6F95     MOVWF value, BANKED
0C18  0E03     MOVLW 0x3
0C1A  6F96     MOVWF divisor, BANKED
0C1C  EC30     CALL 0xC60, 0
0C1E  F006     NOP
207:           	USART_puts(V.str); // send size of data array
0C20  0E5F     MOVLW 0x5F
0C22  0100     MOVLB 0x0
0C24  6F95     MOVWF value, BANKED
0C26  0E00     MOVLW 0x0
0C28  6F96     MOVWF divisor, BANKED
0C2A  EC59     CALL 0xCB2, 0
0C2C  F006     NOP
208:           }
0C2E  0012     RETURN 0
209:           
210:           /* main loop work routine */
211:           int16_t sw_work(void)
212:           {
213:           	static uint8_t position = 0, offset = 0, rx_data;
214:           	static uint8_t *L_tmp_ptr;
215:           
216:           	static union L_union_type { // so we can access each byte of the command structure
217:           		uint8_t L_bytes[sizeof(L[0]) + 1];
218:           		L_data L_tmp;
219:           	} L_union;
220:           	int16_t ret = 0;
038E  0E00     MOVLW 0x0
0390  0100     MOVLB 0x0
0392  6FB1     MOVWF 0xB1, BANKED
0394  0E00     MOVLW 0x0
0396  6FB0     MOVWF ret, BANKED
221:           
222:           	if (V.l_state != ISR_STATE_WAIT)
0398  0E02     MOVLW 0x2
039A  1852     XORWF 0x52, W, ACCESS
039C  B4D8     BTFSC STATUS, 2, ACCESS
039E  D002     BRA 0x3A4
223:           		ret = -1;
03A0  69B0     SETF ret, BANKED
03A2  69B1     SETF 0xB1, BANKED
224:           
225:           	if (!SW1) {
03A4  B880     BTFSC PORTA, 4, ACCESS
03A6  D03F     BRA 0x426
226:           		USART_putsr("\r\n Timer limit,");
03A8  0E2E     MOVLW 0x2E
03AA  6F95     MOVWF value, BANKED
03AC  0E03     MOVLW 0x3
03AE  6F96     MOVWF divisor, BANKED
03B0  EC30     CALL 0xC60, 0
03B2  F006     NOP
227:           		itoa(V.str, V.l_full, 10);
03B4  0E5F     MOVLW 0x5F
03B6  0100     MOVLB 0x0
03B8  6FA4     MOVWF buf, BANKED
03BA  0E00     MOVLW 0x0
03BC  6FA5     MOVWF 0xA5, BANKED
03BE  C05B     MOVFF 0x5B, val
03C0  F0A6     NOP
03C2  C05C     MOVFF 0x5C, 0xA7
03C4  F0A7     NOP
03C6  0E00     MOVLW 0x0
03C8  6FA9     MOVWF 0xA9, BANKED
03CA  0E0A     MOVLW 0xA
03CC  6FA8     MOVWF base, BANKED
03CE  ECB6     CALL 0xB6C, 0
03D0  F005     NOP
228:           		USART_puts(V.str);
03D2  0E5F     MOVLW 0x5F
03D4  0100     MOVLB 0x0
03D6  6F95     MOVWF value, BANKED
03D8  0E00     MOVLW 0x0
03DA  6F96     MOVWF divisor, BANKED
03DC  EC59     CALL 0xCB2, 0
03DE  F006     NOP
229:           		USART_putsr(" Timer value,");
03E0  0E3E     MOVLW 0x3E
03E2  0100     MOVLB 0x0
03E4  6F95     MOVWF value, BANKED
03E6  0E03     MOVLW 0x3
03E8  6F96     MOVWF divisor, BANKED
03EA  EC30     CALL 0xC60, 0
03EC  F006     NOP
230:           		itoa(V.str, L_ptr->strobe, 10);
03EE  0E5F     MOVLW 0x5F
03F0  0100     MOVLB 0x0
03F2  6FA4     MOVWF buf, BANKED
03F4  0E00     MOVLW 0x0
03F6  6FA5     MOVWF 0xA5, BANKED
03F8  EE20     LFSR 2, 0x3
03FA  F003     NOP
03FC  51BA     MOVF L_ptr, W, BANKED
03FE  26D9     ADDWF FSR2, F, ACCESS
0400  51BB     MOVF 0xBB, W, BANKED
0402  22DA     ADDWFC FSR2H, F, ACCESS
0404  CFDE     MOVFF POSTINC2, val
0406  F0A6     NOP
0408  CFDD     MOVFF POSTDEC2, 0xA7
040A  F0A7     NOP
040C  0E00     MOVLW 0x0
040E  6FA9     MOVWF 0xA9, BANKED
0410  0E0A     MOVLW 0xA
0412  6FA8     MOVWF base, BANKED
0414  ECB6     CALL 0xB6C, 0
0416  F005     NOP
231:           		USART_puts(V.str);
0418  0E5F     MOVLW 0x5F
041A  0100     MOVLB 0x0
041C  6F95     MOVWF value, BANKED
041E  0E00     MOVLW 0x0
0420  6F96     MOVWF divisor, BANKED
0422  EC59     CALL 0xCB2, 0
0424  F006     NOP
232:           	}
233:           
234:           	/* command state machine 
235:           	 * u/U update the current display buffer with remote RS232 data
236:           	 * d/D display the current display buffer on RS232 port
237:           	 * e/E clear/set end of lines flag on display buffer
238:           	 * i/I timer info command
239:           	 * z/Z null command
240:           	 */
241:           	if (!ringBufS_empty(&ring_buf1)) {
0426  0EBF     MOVLW 0xBF
0428  0100     MOVLB 0x0
042A  6F94     MOVWF dividend, BANKED
042C  0E00     MOVLW 0x0
042E  6F95     MOVWF value, BANKED
0430  EC8B     CALL 0xD16, 0
0432  F006     NOP
0434  0900     IORLW 0x0
0436  A4D8     BTFSS STATUS, 2, ACCESS
0438  0012     RETURN 0
242:           		rx_data = ringBufS_get(&ring_buf1);
043A  0EBF     MOVLW 0xBF
043C  0100     MOVLB 0x0
043E  6F97     MOVWF _this, BANKED
0440  0E00     MOVLW 0x0
0442  6F98     MOVWF counter, BANKED
0444  ECF1     CALL 0x9E2, 0
0446  F004     NOP
0448  0100     MOVLB 0x0
044A  6FBC     MOVWF rx_data, BANKED
243:           		switch (V.comm_state) {
044C  D164     BRA 0x716
0716  5051     MOVF V, W, ACCESS
0718  0A00     XORLW 0x0
071A  B4D8     BTFSC STATUS, 2, ACCESS
071C  D6E0     BRA 0x4DE
071E  0A01     XORLW 0x1
0720  B4D8     BTFSC STATUS, 2, ACCESS
0722  D6FD     BRA 0x51E
0724  0A03     XORLW 0x3
0726  B4D8     BTFSC STATUS, 2, ACCESS
0728  D73E     BRA 0x5A6
072A  0A01     XORLW 0x1
072C  B4D8     BTFSC STATUS, 2, ACCESS
072E  D6F7     BRA 0x51E
0730  0A07     XORLW 0x7
0732  B4D8     BTFSC STATUS, 2, ACCESS
0734  D778     BRA 0x626
0736  0A01     XORLW 0x1
0738  B4D8     BTFSC STATUS, 2, ACCESS
073A  D6F1     BRA 0x51E
073C  0A03     XORLW 0x3
073E  B4D8     BTFSC STATUS, 2, ACCESS
0740  D6EE     BRA 0x51E
0742  D7C9     BRA 0x6D6
244:           		case APP_STATE_INIT:
245:           			switch (rx_data) {
04DE  51BC     MOVF rx_data, W, BANKED
04E0  0A44     XORLW 0x44
04E2  B4D8     BTFSC STATUS, 2, ACCESS
04E4  D7B7     BRA 0x454
04E6  0A01     XORLW 0x1
04E8  B4D8     BTFSC STATUS, 2, ACCESS
04EA  D7C0     BRA 0x46C
04EC  0A0C     XORLW 0xC
04EE  B4D8     BTFSC STATUS, 2, ACCESS
04F0  D7C6     BRA 0x47E
04F2  0A1C     XORLW 0x1C
04F4  B4D8     BTFSC STATUS, 2, ACCESS
04F6  D7AB     BRA 0x44E
04F8  0A0F     XORLW 0xF
04FA  B4D8     BTFSC STATUS, 2, ACCESS
04FC  0012     RETURN 0
04FE  0A3E     XORLW 0x3E
0500  B4D8     BTFSC STATUS, 2, ACCESS
0502  D7A8     BRA 0x454
0504  0A01     XORLW 0x1
0506  B4D8     BTFSC STATUS, 2, ACCESS
0508  D7A8     BRA 0x45A
050A  0A0C     XORLW 0xC
050C  B4D8     BTFSC STATUS, 2, ACCESS
050E  D7B7     BRA 0x47E
0510  0A1C     XORLW 0x1C
0512  B4D8     BTFSC STATUS, 2, ACCESS
0514  D79C     BRA 0x44E
0516  0A0F     XORLW 0xF
0518  B4D8     BTFSC STATUS, 2, ACCESS
051A  0012     RETURN 0
051C  D7D5     BRA 0x4C8
246:           			case 'u':
247:           			case 'U':
248:           				V.comm_state = APP_STATE_WAIT_FOR_UDATA;
044E  0E01     MOVLW 0x1
0450  6E51     MOVWF V, ACCESS
249:           				break;
0452  0012     RETURN 0
250:           			case 'd':
251:           			case 'D':
252:           				V.comm_state = APP_STATE_WAIT_FOR_DDATA;
0454  0E03     MOVLW 0x3
0456  6E51     MOVWF V, ACCESS
253:           				break;
0458  0012     RETURN 0
254:           			case 'e':
255:           				V.comm_state = APP_STATE_WAIT_FOR_eDATA;
045A  0E05     MOVLW 0x5
045C  6E51     MOVWF V, ACCESS
256:           				puts_ok(V.l_size);
045E  C055     MOVFF 0x55, size
0460  F0AC     NOP
0462  C056     MOVFF 0x56, 0xAD
0464  F0AD     NOP
0466  ECFA     CALL 0xBF4, 0
0468  F005     NOP
257:           				break;
046A  0012     RETURN 0
258:           			case 'E':
259:           				V.comm_state = APP_STATE_WAIT_FOR_EDATA;
046C  0E06     MOVLW 0x6
046E  6E51     MOVWF V, ACCESS
260:           				puts_ok(V.l_size);
0470  C055     MOVFF 0x55, size
0472  F0AC     NOP
0474  C056     MOVFF 0x56, 0xAD
0476  F0AD     NOP
0478  ECFA     CALL 0xBF4, 0
047A  F005     NOP
261:           				break;
047C  0012     RETURN 0
262:           			case 'i':
263:           			case 'I': // info command
264:           				USART_putsr(" Timer limit,");
047E  0E30     MOVLW 0x30
0480  0100     MOVLB 0x0
0482  6F95     MOVWF value, BANKED
0484  0E03     MOVLW 0x3
0486  6F96     MOVWF divisor, BANKED
0488  EC30     CALL 0xC60, 0
048A  F006     NOP
265:           				itoa(V.str, V.l_full, 10);
048C  0E5F     MOVLW 0x5F
048E  0100     MOVLB 0x0
0490  6FA4     MOVWF buf, BANKED
0492  0E00     MOVLW 0x0
0494  6FA5     MOVWF 0xA5, BANKED
0496  C05B     MOVFF 0x5B, val
0498  F0A6     NOP
049A  C05C     MOVFF 0x5C, 0xA7
049C  F0A7     NOP
049E  0E00     MOVLW 0x0
04A0  6FA9     MOVWF 0xA9, BANKED
04A2  0E0A     MOVLW 0xA
04A4  6FA8     MOVWF base, BANKED
04A6  ECB6     CALL 0xB6C, 0
04A8  F005     NOP
266:           				USART_puts(V.str);
04AA  0E5F     MOVLW 0x5F
04AC  0100     MOVLB 0x0
04AE  6F95     MOVWF value, BANKED
04B0  0E00     MOVLW 0x0
04B2  6F96     MOVWF divisor, BANKED
04B4  EC59     CALL 0xCB2, 0
04B6  F006     NOP
267:           				USART_putsr(" OK");
04B8  0E7D     MOVLW 0x7D
04BA  0100     MOVLB 0x0
04BC  6F95     MOVWF value, BANKED
04BE  0E03     MOVLW 0x3
04C0  6F96     MOVWF divisor, BANKED
04C2  EC30     CALL 0xC60, 0
04C4  F006     NOP
268:           				break;
269:           			case 'z':
270:           			case 'Z': // null command for fillers, silent
271:           				break;
04C6  0012     RETURN 0
272:           			default:
273:           				USART_putsr("\r\n NAK_I");
04C8  0E64     MOVLW 0x64
04CA  0100     MOVLB 0x0
04CC  6F95     MOVWF value, BANKED
04CE  0E03     MOVLW 0x3
04D0  6F96     MOVWF divisor, BANKED
04D2  EC30     CALL 0xC60, 0
04D4  F006     NOP
274:           				ret = -1;
04D6  0100     MOVLB 0x0
04D8  69B0     SETF ret, BANKED
04DA  69B1     SETF 0xB1, BANKED
275:           				break;
276:           			}
04DC  0012     RETURN 0
277:           			break;
278:           		case APP_STATE_WAIT_FOR_eDATA:
279:           		case APP_STATE_WAIT_FOR_EDATA:
280:           		case APP_STATE_WAIT_FOR_DDATA:
281:           		case APP_STATE_WAIT_FOR_UDATA:
282:           			position = rx_data;
051E  C0BC     MOVFF rx_data, position
0520  F0BE     NOP
283:           			if (position >= strobe_max) {
0522  0E0F     MOVLW 0xF
0524  65BE     CPFSGT position, BANKED
0526  D00C     BRA 0x540
284:           				USART_putsr(" NAK_P");
0528  0E74     MOVLW 0x74
052A  6F95     MOVWF value, BANKED
052C  0E03     MOVLW 0x3
052E  6F96     MOVWF divisor, BANKED
0530  EC30     CALL 0xC60, 0
0532  F006     NOP
285:           				V.comm_state = APP_STATE_INIT;
0534  0E00     MOVLW 0x0
0536  6E51     MOVWF V, ACCESS
286:           				ret = -1;
0538  0100     MOVLB 0x0
053A  69B0     SETF ret, BANKED
053C  69B1     SETF 0xB1, BANKED
287:           				break;
053E  0012     RETURN 0
288:           			}
289:           			offset = 0;
0540  0E00     MOVLW 0x0
0542  6FBD     MOVWF offset, BANKED
290:           			switch (V.comm_state) {
0544  D01C     BRA 0x57E
057E  5051     MOVF V, W, ACCESS
0580  0A01     XORLW 0x1
0582  B4D8     BTFSC STATUS, 2, ACCESS
0584  D7E0     BRA 0x546
0586  0A02     XORLW 0x2
0588  B4D8     BTFSC STATUS, 2, ACCESS
058A  D7EB     BRA 0x562
058C  0A06     XORLW 0x6
058E  B4D8     BTFSC STATUS, 2, ACCESS
0590  D7DD     BRA 0x54C
0592  0A03     XORLW 0x3
0594  B4D8     BTFSC STATUS, 2, ACCESS
0596  D7E7     BRA 0x566
291:           			case APP_STATE_WAIT_FOR_UDATA:
292:           				V.comm_state = APP_STATE_WAIT_FOR_RDATA;
0546  0E02     MOVLW 0x2
293:           				break;
294:           			case APP_STATE_WAIT_FOR_DDATA:
295:           				V.comm_state = APP_STATE_WAIT_FOR_SDATA;
0548  6E51     MOVWF V, ACCESS
296:           				break;
054A  D026     BRA 0x598
297:           			case APP_STATE_WAIT_FOR_eDATA:
298:           				INTCONbits.GIEH = 0;
054C  9EF2     BCF INTCON, 7, ACCESS
299:           				L[position].sequence.end = 0; // clear end flag
054E  51BE     MOVF position, W, BANKED
0550  0D05     MULLW 0x5
0552  0E01     MOVLW 0x1
0554  24F3     ADDWF PROD, W, ACCESS
0556  6ED9     MOVWF FSR2, ACCESS
0558  0E00     MOVLW 0x0
055A  20F4     ADDWFC PRODH, W, ACCESS
055C  6EDA     MOVWF FSR2H, ACCESS
055E  98DF     BCF INDF2, 4, ACCESS
300:           				INTCONbits.GIEH = 1;
0560  D00C     BRA 0x57A
301:           				V.comm_state = APP_STATE_WAIT_FOR_SDATA;
0562  0E04     MOVLW 0x4
0564  D7F1     BRA 0x548
302:           				break;
303:           			case APP_STATE_WAIT_FOR_EDATA:
304:           				INTCONbits.GIEH = 0;
0566  9EF2     BCF INTCON, 7, ACCESS
305:           				L[position].sequence.end = 1; // set end flag
0568  51BE     MOVF position, W, BANKED
056A  0D05     MULLW 0x5
056C  0E01     MOVLW 0x1
056E  24F3     ADDWF PROD, W, ACCESS
0570  6ED9     MOVWF FSR2, ACCESS
0572  0E00     MOVLW 0x0
0574  20F4     ADDWFC PRODH, W, ACCESS
0576  6EDA     MOVWF FSR2H, ACCESS
0578  88DF     BSF INDF2, 4, ACCESS
306:           				INTCONbits.GIEH = 1;
057A  8EF2     BSF INTCON, 7, ACCESS
307:           				V.comm_state = APP_STATE_WAIT_FOR_SDATA;
057C  D7F2     BRA 0x562
308:           				break;
309:           			default:
310:           				break;
311:           			}
312:           			USART_putsr(" OK");
0598  0E7D     MOVLW 0x7D
059A  6F95     MOVWF value, BANKED
059C  0E03     MOVLW 0x3
059E  6F96     MOVWF divisor, BANKED
05A0  EC30     CALL 0xC60, 0
05A2  F006     NOP
313:           			break;
05A4  0012     RETURN 0
314:           		case APP_STATE_WAIT_FOR_RDATA: // receive
315:           			L_union.L_bytes[offset] = rx_data;
05A6  0100     MOVLB 0x0
05A8  51BD     MOVF offset, W, BANKED
05AA  0D01     MULLW 0x1
05AC  0EB2     MOVLW 0xB2
05AE  24F3     ADDWF PROD, W, ACCESS
05B0  6ED9     MOVWF FSR2, ACCESS
05B2  0E00     MOVLW 0x0
05B4  20F4     ADDWFC PRODH, W, ACCESS
05B6  6EDA     MOVWF FSR2H, ACCESS
05B8  C0BC     MOVFF rx_data, INDF2
05BA  FFDF     NOP
316:           			offset++;
05BC  2BBD     INCF offset, F, BANKED
317:           			if (offset >= sizeof(L_union.L_tmp)) {
05BE  0E04     MOVLW 0x4
05C0  65BD     CPFSGT offset, BANKED
05C2  0012     RETURN 0
318:           				INTCONbits.GIEH = 0;
05C4  9EF2     BCF INTCON, 7, ACCESS
319:           				L[position] = L_union.L_tmp;
05C6  EE20     LFSR 2, 0xB2
05C8  F0B2     NOP
05CA  51BE     MOVF position, W, BANKED
05CC  0D05     MULLW 0x5
05CE  0E01     MOVLW 0x1
05D0  24F3     ADDWF PROD, W, ACCESS
05D2  6EE1     MOVWF FSR1, ACCESS
05D4  0E00     MOVLW 0x0
05D6  20F4     ADDWFC PRODH, W, ACCESS
05D8  6EE2     MOVWF FSR1H, ACCESS
05DA  0E04     MOVLW 0x4
05DC  CFDB     MOVFF PLUSW2, PLUSW1
05DE  FFE3     NOP
05E0  06E8     DECF WREG, F, ACCESS
05E2  E2FC     BC 0x5DC
320:           				INTCONbits.INT0IF = false;
05E4  92F2     BCF INTCON, 1, ACCESS
321:           				INTCONbits.GIEH = 1;
05E6  8EF2     BSF INTCON, 7, ACCESS
322:           				USART_putsr(" OK,");
05E8  0E81     MOVLW 0x81
05EA  6F95     MOVWF value, BANKED
05EC  0E03     MOVLW 0x3
05EE  6F96     MOVWF divisor, BANKED
05F0  EC30     CALL 0xC60, 0
05F2  F006     NOP
323:           				utoa(V.str, (uint16_t) L_union.L_tmp.strobe, 10);
05F4  0E5F     MOVLW 0x5F
05F6  0100     MOVLB 0x0
05F8  6F9B     MOVWF buf, BANKED
05FA  0E00     MOVLW 0x0
05FC  6F9C     MOVWF _this, BANKED
05FE  C0B5     MOVFF 0xB5, val
0600  F09D     NOP
0602  C0B6     MOVFF 0xB6, clearBuffer
0604  F09E     NOP
0606  0E00     MOVLW 0x0
0608  6FA0     MOVWF 0xA0, BANKED
060A  0E0A     MOVLW 0xA
060C  6F9F     MOVWF base, BANKED
060E  EC9C     CALL 0x938, 0
0610  F004     NOP
324:           				USART_puts(V.str);
0612  0E5F     MOVLW 0x5F
0614  0100     MOVLB 0x0
0616  6F95     MOVWF value, BANKED
0618  0E00     MOVLW 0x0
061A  6F96     MOVWF divisor, BANKED
061C  EC59     CALL 0xCB2, 0
061E  F006     NOP
325:           				V.comm_state = APP_STATE_INIT;
0620  0E00     MOVLW 0x0
0622  6E51     MOVWF V, ACCESS
326:           			}
327:           			break;
0624  0012     RETURN 0
328:           		case APP_STATE_WAIT_FOR_SDATA: // send
329:           			L_tmp_ptr = (void*) &L[position]; // set array start position
0626  0100     MOVLB 0x0
0628  51BE     MOVF position, W, BANKED
062A  0D05     MULLW 0x5
062C  0E01     MOVLW 0x1
062E  24F3     ADDWF PROD, W, ACCESS
0630  6FB8     MOVWF L_tmp_ptr, BANKED
0632  0E00     MOVLW 0x0
0634  20F4     ADDWFC PRODH, W, ACCESS
0636  6FB9     MOVWF 0xB9, BANKED
330:           			do { // send ascii data to the rs232 port
331:           				USART_putsr(" ,");
0638  0E89     MOVLW 0x89
063A  6F95     MOVWF value, BANKED
063C  0E03     MOVLW 0x3
063E  6F96     MOVWF divisor, BANKED
0640  EC30     CALL 0xC60, 0
0642  F006     NOP
332:           				if (offset) {
0644  0100     MOVLB 0x0
0646  51BD     MOVF offset, W, BANKED
0648  B4D8     BTFSC STATUS, 2, ACCESS
064A  D014     BRA 0x674
333:           					itoa(V.str, *L_tmp_ptr, 16); // show hex
064C  0E5F     MOVLW 0x5F
064E  6FA4     MOVWF buf, BANKED
0650  0E00     MOVLW 0x0
0652  6FA5     MOVWF 0xA5, BANKED
0654  C0B8     MOVFF L_tmp_ptr, FSR2
0656  FFD9     NOP
0658  C0B9     MOVFF 0xB9, FSR2H
065A  FFDA     NOP
065C  50DF     MOVF INDF2, W, ACCESS
065E  6FAE     MOVWF 0xAE, BANKED
0660  51AE     MOVF 0xAE, W, BANKED
0662  6FA6     MOVWF val, BANKED
0664  6BA7     CLRF 0xA7, BANKED
0666  0E00     MOVLW 0x0
0668  6FA9     MOVWF 0xA9, BANKED
066A  0E10     MOVLW 0x10
066C  6FA8     MOVWF base, BANKED
066E  ECB6     CALL 0xB6C, 0
0670  F005     NOP
334:           				} else {
0672  D014     BRA 0x69C
335:           					itoa(V.str, *L_tmp_ptr, 2); // show bits
0674  0E5F     MOVLW 0x5F
0676  0100     MOVLB 0x0
0678  6FA4     MOVWF buf, BANKED
067A  0E00     MOVLW 0x0
067C  6FA5     MOVWF 0xA5, BANKED
067E  C0B8     MOVFF L_tmp_ptr, FSR2
0680  FFD9     NOP
0682  C0B9     MOVFF 0xB9, FSR2H
0684  FFDA     NOP
0686  50DF     MOVF INDF2, W, ACCESS
0688  6FAE     MOVWF 0xAE, BANKED
068A  51AE     MOVF 0xAE, W, BANKED
068C  6FA6     MOVWF val, BANKED
068E  6BA7     CLRF 0xA7, BANKED
0690  0E00     MOVLW 0x0
0692  6FA9     MOVWF 0xA9, BANKED
0694  0E02     MOVLW 0x2
0696  6FA8     MOVWF base, BANKED
0698  ECB6     CALL 0xB6C, 0
069A  F005     NOP
336:           				}
337:           				USART_puts(V.str);
069C  0E5F     MOVLW 0x5F
069E  0100     MOVLB 0x0
06A0  6F95     MOVWF value, BANKED
06A2  0E00     MOVLW 0x0
06A4  6F96     MOVWF divisor, BANKED
06A6  EC59     CALL 0xCB2, 0
06A8  F006     NOP
338:           				L_tmp_ptr++;
06AA  0100     MOVLB 0x0
06AC  4BB8     INFSNZ L_tmp_ptr, F, BANKED
06AE  2BB9     INCF 0xB9, F, BANKED
339:           				offset++;
06B0  2BBD     INCF offset, F, BANKED
340:           			} while (offset < V.l_size);
06B2  51BD     MOVF offset, W, BANKED
06B4  6FAE     MOVWF 0xAE, BANKED
06B6  6BAF     CLRF 0xAF, BANKED
06B8  5055     MOVF 0x55, W, ACCESS
06BA  5DAE     SUBWF 0xAE, W, BANKED
06BC  5056     MOVF 0x56, W, ACCESS
06BE  59AF     SUBWFB 0xAF, W, BANKED
06C0  A0D8     BTFSS STATUS, 0, ACCESS
06C2  D7BA     BRA 0x638
341:           			V.comm_state = APP_STATE_INIT;
06C4  0E00     MOVLW 0x0
06C6  6E51     MOVWF V, ACCESS
342:           			USART_putsr(" OK");
06C8  0E7D     MOVLW 0x7D
06CA  6F95     MOVWF value, BANKED
06CC  0E03     MOVLW 0x3
06CE  6F96     MOVWF divisor, BANKED
06D0  EC30     CALL 0xC60, 0
06D2  F006     NOP
343:           			break;
06D4  0012     RETURN 0
344:           		default:
345:           			USART_putsr(" NAK_C");
06D6  0E6D     MOVLW 0x6D
06D8  0100     MOVLB 0x0
06DA  6F95     MOVWF value, BANKED
06DC  0E03     MOVLW 0x3
06DE  6F96     MOVWF divisor, BANKED
06E0  EC30     CALL 0xC60, 0
06E2  F006     NOP
346:           			V.comm_state = APP_STATE_INIT;
06E4  0E00     MOVLW 0x0
06E6  6E51     MOVWF V, ACCESS
347:           			if (ringBufS_full(&ring_buf1))
06E8  0EBF     MOVLW 0xBF
06EA  0100     MOVLB 0x0
06EC  6F94     MOVWF dividend, BANKED
06EE  0E00     MOVLW 0x0
06F0  6F95     MOVWF value, BANKED
06F2  EC7C     CALL 0xCF8, 0
06F4  F006     NOP
06F6  0900     IORLW 0x0
06F8  B4D8     BTFSC STATUS, 2, ACCESS
06FA  D009     BRA 0x70E
348:           				ringBufS_flush(&ring_buf1, 0);
06FC  0EBF     MOVLW 0xBF
06FE  0100     MOVLB 0x0
0700  6F9C     MOVWF _this, BANKED
0702  0E00     MOVLW 0x0
0704  6F9D     MOVWF val, BANKED
0706  0E00     MOVLW 0x0
0708  6F9E     MOVWF clearBuffer, BANKED
070A  EC61     CALL 0xAC2, 0
070C  F005     NOP
349:           			ret = -1;
070E  0100     MOVLB 0x0
0710  69B0     SETF ret, BANKED
0712  69B1     SETF 0xB1, BANKED
350:           			break;
351:           		}
0714  0012     RETURN 0
0716  5051     MOVF V, W, ACCESS
0718  0A00     XORLW 0x0
071A  B4D8     BTFSC STATUS, 2, ACCESS
071C  D6E0     BRA 0x4DE
071E  0A01     XORLW 0x1
0720  B4D8     BTFSC STATUS, 2, ACCESS
0722  D6FD     BRA 0x51E
0724  0A03     XORLW 0x3
0726  B4D8     BTFSC STATUS, 2, ACCESS
0728  D73E     BRA 0x5A6
072A  0A01     XORLW 0x1
072C  B4D8     BTFSC STATUS, 2, ACCESS
072E  D6F7     BRA 0x51E
0730  0A07     XORLW 0x7
0732  B4D8     BTFSC STATUS, 2, ACCESS
0734  D778     BRA 0x626
0736  0A01     XORLW 0x1
0738  B4D8     BTFSC STATUS, 2, ACCESS
073A  D6F1     BRA 0x51E
073C  0A03     XORLW 0x3
073E  B4D8     BTFSC STATUS, 2, ACCESS
0740  D6EE     BRA 0x51E
0742  D7C9     BRA 0x6D6
352:           	}
353:           
354:           	return ret;
355:           }
356:           
357:           /* controller hardware setup */
358:           void init_povmon(void)
359:           {
360:           	/*
361:           	 * check for a clean POR
362:           	 */
363:           	V.boot_code = false;
0864  9053     BCF 0x53, 0, ACCESS
364:           	if (RCON != 0b0011100)
0866  0E1C     MOVLW 0x1C
0868  18D0     XORWF RCON, W, ACCESS
086A  A4D8     BTFSS STATUS, 2, ACCESS
365:           		V.boot_code = true;
086C  8053     BSF 0x53, 0, ACCESS
366:           
367:           	if (STKPTRbits.STKFUL || STKPTRbits.STKUNF) {
086E  BEFC     BTFSC STKPTR, 7, ACCESS
0870  D002     BRA 0x876
0872  ACFC     BTFSS STKPTR, 6, ACCESS
0874  D003     BRA 0x87C
368:           		V.boot_code = true;
0876  8053     BSF 0x53, 0, ACCESS
369:           		STKPTRbits.STKFUL = 0;
0878  9EFC     BCF STKPTR, 7, ACCESS
370:           		STKPTRbits.STKUNF = 0;
087A  9CFC     BCF STKPTR, 6, ACCESS
371:           	}
372:           
373:           	ADCON1 = 0x7F; // all digital, no ADC
087C  0E7F     MOVLW 0x7F
087E  6EC1     MOVWF ADCON1, ACCESS
374:           	/* interrupt priority ON */
375:           	RCONbits.IPEN = 1;
0880  8ED0     BSF RCON, 7, ACCESS
376:           	/* define I/O ports */
377:           	RMSPORTA = RMSPORT_IOA;
0882  0E10     MOVLW 0x10
0884  6E92     MOVWF TRISA, ACCESS
378:           	RMSPORTB = RMSPORT_IOB;
0886  0E11     MOVLW 0x11
0888  6E93     MOVWF TRISB, ACCESS
379:           
380:           	G_OUT = OFF; // preset all LEDS
088A  9089     BCF LATA, 0, ACCESS
381:           	LED1 = OFF;
088C  9689     BCF LATA, 3, ACCESS
382:           	LED2 = OFF;
088E  9689     BCF LATA, 3, ACCESS
383:           	LED3 = OFF;
0890  9689     BCF LATA, 3, ACCESS
384:           	LED4 = OFF;
0892  9C8A     BCF LATB, 6, ACCESS
385:           	LED5 = OFF;
0894  9E8A     BCF LATB, 7, ACCESS
386:           	LED6 = OFF;
0896  9C89     BCF LATA, 6, ACCESS
387:           	RPMLED = OFF;
0898  9A8A     BCF LATB, 5, ACCESS
388:           	//	OpenTimer0(TIMER_INT_ON & T0_16BIT & T0_SOURCE_INT & T0_PS_1_256); // led blinker
389:           	T0CON = 0b10000111;
089A  0E87     MOVLW 0x87
089C  6ED5     MOVWF T0CON, ACCESS
390:           	WRITETIMER0(TIMEROFFSET); //	start timer0 at ~1/2 second ticks
089E  0E13     MOVLW 0x13
08A0  6EF6     MOVWF TBLPTR, ACCESS
08A2  0E03     MOVLW 0x3
08A4  6EF7     MOVWF TBLPTRH, ACCESS
08A6  0009     TBLRD*+
08A8  CFF5     MOVFF TABLAT, size
08AA  F0AC     NOP
08AC  0009     TBLRD*+
08AE  CFF5     MOVFF TABLAT, 0xAD
08B0  F0AD     NOP
08B2  C0AD     MOVFF 0xAD, size
08B4  F0AC     NOP
08B6  0100     MOVLB 0x0
08B8  6BAD     CLRF 0xAD, BANKED
08BA  51AC     MOVF size, W, BANKED
08BC  6ED7     MOVWF TMR0H, ACCESS
08BE  0E13     MOVLW 0x13
08C0  6EF6     MOVWF TBLPTR, ACCESS
08C2  0E03     MOVLW 0x3
08C4  6EF7     MOVWF TBLPTRH, ACCESS
08C6  0008     TBLRD*
08C8  CFF5     MOVFF TABLAT, TMR0
08CA  FFD6     NOP
391:           	//	OpenTimer1(TIMER_INT_ON & T1_16BIT_RW & T1_SOURCE_INT & T1_PS_1_2 & T1_OSC1EN_OFF & T1_SYNC_EXT_OFF); // strobe position clock
392:           	T1CON = 0b10010101;
08CC  0E95     MOVLW 0x95
08CE  6ECD     MOVWF T1CON, ACCESS
393:           	WRITETIMER1(TIMERDEF);
08D0  0E11     MOVLW 0x11
08D2  6EF6     MOVWF TBLPTR, ACCESS
08D4  0E03     MOVLW 0x3
08D6  6EF7     MOVWF TBLPTRH, ACCESS
08D8  0009     TBLRD*+
08DA  CFF5     MOVFF TABLAT, size
08DC  F0AC     NOP
08DE  0009     TBLRD*+
08E0  CFF5     MOVFF TABLAT, 0xAD
08E2  F0AD     NOP
08E4  C0AD     MOVFF 0xAD, size
08E6  F0AC     NOP
08E8  6BAD     CLRF 0xAD, BANKED
08EA  51AC     MOVF size, W, BANKED
08EC  6ECF     MOVWF TMR1H, ACCESS
08EE  0E11     MOVLW 0x11
08F0  6EF6     MOVWF TBLPTR, ACCESS
08F2  0E03     MOVLW 0x3
08F4  6EF7     MOVWF TBLPTRH, ACCESS
08F6  0008     TBLRD*
08F8  CFF5     MOVFF TABLAT, TMR1
08FA  FFCE     NOP
394:           	/* data link */
395:           	COMM_ENABLE = true; // for PICDEM4 onboard RS-232, not used on custom boards
08FC  868A     BSF LATB, 3, ACCESS
396:           	TXSTAbits.TXEN = 1;
08FE  8AAC     BSF TXSTA, 5, ACCESS
397:           	RCSTAbits.CREN = 1;
0900  88AB     BSF RCSTA, 4, ACCESS
398:           	RCSTAbits.SPEN = 1;
0902  8EAB     BSF RCSTA, 7, ACCESS
399:           	TXSTAbits.SYNC = 0;
0904  98AC     BCF TXSTA, 4, ACCESS
400:           	TXSTAbits.SYNC = 0;
0906  98AC     BCF TXSTA, 4, ACCESS
401:           	TXSTAbits.BRGH = 0;
0908  94AC     BCF TXSTA, 2, ACCESS
402:           	BAUDCTLbits.BRG16 = 1;
090A  86AA     BSF BAUDCTL, 3, ACCESS
403:           	SPBRG = 129; /* 19200 baud */
090C  0E81     MOVLW 0x81
090E  6EAF     MOVWF SPBRG, ACCESS
404:           
405:           	/*      work int thread setup */
406:           	INTCONbits.TMR0IE = 1; // enable int
0910  8AF2     BSF INTCON, 5, ACCESS
407:           	INTCON2bits.TMR0IP = 1; // make it high P
0912  84F1     BSF INTCON2, 2, ACCESS
408:           
409:           	/* rotation timer */
410:           	PIE1bits.TMR1IE = 1;
0914  809D     BSF PIE1, 0, ACCESS
411:           	IPR1bits.TMR1IP = 1;
0916  809F     BSF IPR1, 0, ACCESS
412:           
413:           	INTCONbits.INT0IE = 1; // enable RPM sensor input
0918  88F2     BSF INTCON, 4, ACCESS
414:           	INTCON2bits.INTEDG0 = 0; // falling edge trigger
091A  9CF1     BCF INTCON2, 6, ACCESS
415:           	INTCON2bits.RBPU = 0; // enable weak pull-ups
091C  9EF1     BCF INTCON2, 7, ACCESS
416:           
417:           	PIE1bits.RCIE = 1; // enable rs232 serial receive interrupts
091E  8A9D     BSF PIE1, 5, ACCESS
418:           	IPR1bits.RCIP = 1;
0920  8A9F     BSF IPR1, 5, ACCESS
419:           
420:           	init_hov_params();
0922  ECA2     CALL 0x744, 0
0924  F003     NOP
421:           	ringBufS_init(&ring_buf1);
0926  0EBF     MOVLW 0xBF
0928  0100     MOVLB 0x0
092A  6F9C     MOVWF _this, BANKED
092C  0E00     MOVLW 0x0
092E  6F9D     MOVWF val, BANKED
0930  EC6C     CALL 0xCD8, 0
0932  F006     NOP
422:           
423:           	/* Enable all high priority interrupts */
424:           	INTCONbits.GIEH = 1;
0934  8EF2     BSF INTCON, 7, ACCESS
425:           }
0936  0012     RETURN 0
426:           
427:           /* program data setup */
428:           uint8_t init_hov_params(void)
429:           {
430:           	V.line_num = 0;
0744  0EF9     MOVLW 0xF9
0746  1653     ANDWF 0x53, F, ACCESS
431:           	V.comm_state = APP_STATE_INIT;
0748  0E00     MOVLW 0x0
074A  6E51     MOVWF V, ACCESS
432:           	V.l_size = sizeof(L[0]);
074C  0E00     MOVLW 0x0
074E  6E56     MOVWF 0x56, ACCESS
0750  0E05     MOVLW 0x5
0752  6E55     MOVWF 0x55, ACCESS
433:           	V.l_state = ISR_STATE_WAIT;
0754  0E02     MOVLW 0x2
0756  6E52     MOVWF 0x52, ACCESS
434:           	V.l_full = strobe_limit_l;
0758  0E5E     MOVLW 0x5E
075A  6E5C     MOVWF 0x5C, ACCESS
075C  0EBA     MOVLW 0xBA
075E  6E5B     MOVWF 0x5B, ACCESS
435:           	V.l_width = strobe_line;
0760  0EFD     MOVLW 0xFD
0762  6E5E     MOVWF 0x5E, ACCESS
0764  0E84     MOVLW 0x84
0766  6E5D     MOVWF 0x5D, ACCESS
436:           
437:           	USART_putsr("\r\nVersion ");
0768  0E59     MOVLW 0x59
076A  0100     MOVLB 0x0
076C  6F95     MOVWF value, BANKED
076E  0E03     MOVLW 0x3
0770  6F96     MOVWF divisor, BANKED
0772  EC30     CALL 0xC60, 0
0774  F006     NOP
438:           	USART_putsr(versions);
0776  0E2A     MOVLW 0x2A
0778  0100     MOVLB 0x0
077A  6F95     MOVWF value, BANKED
077C  0E03     MOVLW 0x3
077E  6F96     MOVWF divisor, BANKED
0780  EC30     CALL 0xC60, 0
0782  F006     NOP
439:           	USART_putsr(", ");
0784  0E86     MOVLW 0x86
0786  0100     MOVLB 0x0
0788  6F95     MOVWF value, BANKED
078A  0E03     MOVLW 0x3
078C  6F96     MOVWF divisor, BANKED
078E  EC30     CALL 0xC60, 0
0790  F006     NOP
440:           	itoa(V.str, sizeof(L[0]), 10);
0792  0E5F     MOVLW 0x5F
0794  0100     MOVLB 0x0
0796  6FA4     MOVWF buf, BANKED
0798  0E00     MOVLW 0x0
079A  6FA5     MOVWF 0xA5, BANKED
079C  0E00     MOVLW 0x0
079E  6FA7     MOVWF 0xA7, BANKED
07A0  0E05     MOVLW 0x5
07A2  6FA6     MOVWF val, BANKED
07A4  0E00     MOVLW 0x0
07A6  6FA9     MOVWF 0xA9, BANKED
07A8  0E0A     MOVLW 0xA
07AA  6FA8     MOVWF base, BANKED
07AC  ECB6     CALL 0xB6C, 0
07AE  F005     NOP
441:           	USART_puts(V.str);
07B0  0E5F     MOVLW 0x5F
07B2  0100     MOVLB 0x0
07B4  6F95     MOVWF value, BANKED
07B6  0E00     MOVLW 0x0
07B8  6F96     MOVWF divisor, BANKED
07BA  EC59     CALL 0xCB2, 0
07BC  F006     NOP
442:           	USART_putsr(", ");
07BE  0E86     MOVLW 0x86
07C0  0100     MOVLB 0x0
07C2  6F95     MOVWF value, BANKED
07C4  0E03     MOVLW 0x3
07C6  6F96     MOVWF divisor, BANKED
07C8  EC30     CALL 0xC60, 0
07CA  F006     NOP
443:           	USART_putsr(build_date);
07CC  0E15     MOVLW 0x15
07CE  0100     MOVLB 0x0
07D0  6F95     MOVWF value, BANKED
07D2  0E03     MOVLW 0x3
07D4  6F96     MOVWF divisor, BANKED
07D6  EC30     CALL 0xC60, 0
07D8  F006     NOP
444:           	USART_putsr(", ");
07DA  0E86     MOVLW 0x86
07DC  0100     MOVLB 0x0
07DE  6F95     MOVWF value, BANKED
07E0  0E03     MOVLW 0x3
07E2  6F96     MOVWF divisor, BANKED
07E4  EC30     CALL 0xC60, 0
07E6  F006     NOP
445:           	USART_putsr(build_time);
07E8  0E21     MOVLW 0x21
07EA  0100     MOVLB 0x0
07EC  6F95     MOVWF value, BANKED
07EE  0E03     MOVLW 0x3
07F0  6F96     MOVWF divisor, BANKED
07F2  EC30     CALL 0xC60, 0
07F4  F006     NOP
446:           	if (V.boot_code)
07F6  A053     BTFSS 0x53, 0, ACCESS
07F8  D007     BRA 0x808
447:           		USART_putsr(", dirty boot");
07FA  0E4C     MOVLW 0x4C
07FC  0100     MOVLB 0x0
07FE  6F95     MOVWF value, BANKED
0800  0E03     MOVLW 0x3
0802  6F96     MOVWF divisor, BANKED
0804  EC30     CALL 0xC60, 0
0806  F006     NOP
448:           
449:           	L_ptr = &L[0];
0808  0E01     MOVLW 0x1
080A  0100     MOVLB 0x0
080C  6FBA     MOVWF L_ptr, BANKED
080E  0E00     MOVLW 0x0
0810  6FBB     MOVWF 0xBB, BANKED
450:           	/* three line strobes in 3 16-bit timer values for spacing */
451:           	/* for an interrupt driven state machine */
452:           	L[0].strobe = 60000;
0812  0EEA     MOVLW 0xEA
0814  6E05     MOVWF 0x5, ACCESS
0816  0E60     MOVLW 0x60
0818  6E04     MOVWF 0x4, ACCESS
453:           	L[0].sequence.R = 1;
081A  8201     BSF L, 1, ACCESS
454:           	L[0].sequence.offset = strobe_up;
081C  0E00     MOVLW 0x0
081E  6E03     MOVWF 0x3, ACCESS
0820  0E3C     MOVLW 0x3C
0822  6E02     MOVWF 0x2, ACCESS
455:           
456:           	L[1].strobe = 50000; // 62000
0824  0EC3     MOVLW 0xC3
0826  6E0A     MOVWF 0xA, ACCESS
0828  0E50     MOVLW 0x50
082A  6E09     MOVWF 0x9, ACCESS
457:           	L[1].sequence.G = 1;
082C  8406     BSF 0x6, 2, ACCESS
458:           	L[1].sequence.offset = strobe_down;
082E  0E01     MOVLW 0x1
0830  6E08     MOVWF 0x8, ACCESS
0832  0E68     MOVLW 0x68
0834  6E07     MOVWF 0x7, ACCESS
459:           
460:           	L[2].strobe = 40000;
0836  0E9C     MOVLW 0x9C
0838  6E0F     MOVWF 0xF, ACCESS
083A  0E40     MOVLW 0x40
083C  6E0E     MOVWF 0xE, ACCESS
461:           	L[2].sequence.B = 1;
083E  860B     BSF 0xB, 3, ACCESS
462:           	L[2].sequence.offset = strobe_around;
0840  0E04     MOVLW 0x4
0842  6E0D     MOVWF 0xD, ACCESS
0844  0E38     MOVLW 0x38
0846  6E0C     MOVWF 0xC, ACCESS
463:           
464:           	L[3].strobe = 30000;
0848  0E75     MOVLW 0x75
084A  6E14     MOVWF 0x14, ACCESS
084C  0E30     MOVLW 0x30
084E  6E13     MOVWF 0x13, ACCESS
465:           	L[3].sequence.R = 1;
0850  8210     BSF 0x10, 1, ACCESS
466:           	L[3].sequence.G = 1;
0852  8410     BSF 0x10, 2, ACCESS
467:           	L[3].sequence.B = 1;
0854  8610     BSF 0x10, 3, ACCESS
468:           	L[3].sequence.offset = 0;
0856  0E00     MOVLW 0x0
0858  6E12     MOVWF 0x12, ACCESS
085A  0E00     MOVLW 0x0
085C  6E11     MOVWF 0x11, ACCESS
469:           	L[3].sequence.end = 1;
085E  8810     BSF 0x10, 4, ACCESS
470:           
471:           	L[strobe_max - 1].sequence.end = 1;
0860  884C     BSF 0x4C, 4, ACCESS
0862  0012     RETURN 0
472:           	return 0;
473:           }
474:           
475:           void main(void)
476:           {
477:           	/* configure system */
478:           	init_povmon();
0D70  EC32     CALL 0x864, 0
0D72  F004     NOP
479:           
480:           	/* Loop forever */
481:           	while (true) { // busy work
0D78  D7FD     BRA 0xD74
482:           		sw_work(); // run housekeeping for non-ISR tasks
0D74  ECC7     CALL 0x38E, 0
0D76  F001     NOP
0D78  D7FD     BRA 0xD74
483:           	}
484:           }
---  /opt/microchip/xc8/v1.45/sources/common/memset.c  --------------------------------------------------
1:             #include	<string.h>
2:             
3:             #ifdef _PIC16
4:             far void *
5:             memset(far void * p1, int c, register size_t n)
6:             #else /*  _PIC16 */
7:             void *
8:             memset(void * p1, int c, register size_t n)
9:             #endif /* _PIC16 */
10:            {
11:            
12:            #ifdef _PIC16
13:            	register far char *	p;
14:            #else /*  _PIC16 */
15:            	register char *		p;
16:            #endif /* _PIC16 */
17:            
18:            	p = p1;
0C30  C094     MOVFF dividend, counter
0C32  F09A     NOP
0C34  C095     MOVFF value, buf
0C36  F09B     NOP
19:            	while(n--)
0C38  D009     BRA 0xC4C
0C4C  0100     MOVLB 0x0
20:            		*p++ = c;
0C3A  C09A     MOVFF counter, FSR2
0C3C  FFD9     NOP
0C3E  C09B     MOVFF buf, FSR2H
0C40  FFDA     NOP
0C42  C096     MOVFF divisor, INDF2
0C44  FFDF     NOP
0C46  0100     MOVLB 0x0
0C48  4B9A     INFSNZ counter, F, BANKED
0C4A  2B9B     INCF buf, F, BANKED
0C4C  0100     MOVLB 0x0
0C4E  0798     DECF counter, F, BANKED
0C50  A0D8     BTFSS STATUS, 0, ACCESS
0C52  0799     DECF 0x99, F, BANKED
0C54  2998     INCF counter, W, BANKED
0C56  E1F1     BNZ 0xC3A
0C58  2999     INCF 0x99, W, BANKED
0C5A  B4D8     BTFSC STATUS, 2, ACCESS
0C5C  0012     RETURN 0
0C5E  D7ED     BRA 0xC3A
21:            	return p1;
22:            }
---  /opt/microchip/xc8/v1.45/sources/common/lwmod.c  ---------------------------------------------------
1:             // word unsigned modulus
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwmod(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwmod(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter;
12:            
13:            	if(divisor != 0) {
0BB0  0100     MOVLB 0x0
0BB2  5196     MOVF divisor, W, BANKED
0BB4  1197     IORWF _this, W, BANKED
0BB6  B4D8     BTFSC STATUS, 2, ACCESS
0BB8  D018     BRA 0xBEA
14:            		counter = 1;
0BBA  0E01     MOVLW 0x1
0BBC  6F98     MOVWF counter, BANKED
15:            		while((divisor & 0x8000) == 0) {
0BBE  D004     BRA 0xBC8
16:            			divisor <<= 1;
0BC0  90D8     BCF STATUS, 0, ACCESS
0BC2  3796     RLCF divisor, F, BANKED
0BC4  3797     RLCF _this, F, BANKED
17:            			counter++;
0BC6  2B98     INCF counter, F, BANKED
18:            		}
0BC8  AF97     BTFSS _this, 7, BANKED
0BCA  D7FA     BRA 0xBC0
19:            		do {
20:            			if(divisor <= dividend)
0BCC  5196     MOVF divisor, W, BANKED
0BCE  5D94     SUBWF dividend, W, BANKED
0BD0  5197     MOVF _this, W, BANKED
0BD2  5995     SUBWFB value, W, BANKED
0BD4  A0D8     BTFSS STATUS, 0, ACCESS
0BD6  D004     BRA 0xBE0
21:            				dividend -= divisor;
0BD8  5196     MOVF divisor, W, BANKED
0BDA  5F94     SUBWF dividend, F, BANKED
0BDC  5197     MOVF _this, W, BANKED
0BDE  5B95     SUBWFB value, F, BANKED
22:            			divisor >>= 1;
0BE0  90D8     BCF STATUS, 0, ACCESS
0BE2  3397     RRCF _this, F, BANKED
0BE4  3396     RRCF divisor, F, BANKED
23:            		} while(--counter != 0);
0BE6  2F98     DECFSZ counter, F, BANKED
0BE8  D7F1     BRA 0xBCC
24:            	}
25:            	return dividend;
0BEA  C094     MOVFF dividend, dividend
0BEC  F094     NOP
0BEE  C095     MOVFF value, value
0BF0  F095     NOP
26:            }
0BF2  0012     RETURN 0
---  /opt/microchip/xc8/v1.45/sources/common/lwdiv.c  ---------------------------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwdiv(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwdiv(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned int	quotient;
12:            	unsigned char	counter;
13:            
14:            	quotient = 0;
0B18  0E00     MOVLW 0x0
0B1A  0100     MOVLB 0x0
0B1C  6F99     MOVWF 0x99, BANKED
0B1E  0E00     MOVLW 0x0
0B20  6F98     MOVWF counter, BANKED
15:            	if(divisor != 0) {
0B22  5196     MOVF divisor, W, BANKED
0B24  1197     IORWF _this, W, BANKED
0B26  B4D8     BTFSC STATUS, 2, ACCESS
0B28  D01C     BRA 0xB62
16:            		counter = 1;
0B2A  0E01     MOVLW 0x1
0B2C  6F9A     MOVWF counter, BANKED
17:            		while((divisor & 0x8000) == 0) {
0B2E  D004     BRA 0xB38
18:            			divisor <<= 1;
0B30  90D8     BCF STATUS, 0, ACCESS
0B32  3796     RLCF divisor, F, BANKED
0B34  3797     RLCF _this, F, BANKED
19:            			counter++;
0B36  2B9A     INCF counter, F, BANKED
20:            		}
0B38  AF97     BTFSS _this, 7, BANKED
0B3A  D7FA     BRA 0xB30
21:            		do {
22:            			quotient <<= 1;
0B3C  90D8     BCF STATUS, 0, ACCESS
0B3E  3798     RLCF counter, F, BANKED
0B40  3799     RLCF 0x99, F, BANKED
23:            			if(divisor <= dividend) {
0B42  5196     MOVF divisor, W, BANKED
0B44  5D94     SUBWF dividend, W, BANKED
0B46  5197     MOVF _this, W, BANKED
0B48  5995     SUBWFB value, W, BANKED
0B4A  A0D8     BTFSS STATUS, 0, ACCESS
0B4C  D005     BRA 0xB58
24:            				dividend -= divisor;
0B4E  5196     MOVF divisor, W, BANKED
0B50  5F94     SUBWF dividend, F, BANKED
0B52  5197     MOVF _this, W, BANKED
0B54  5B95     SUBWFB value, F, BANKED
25:            				quotient |= 1;
0B56  8198     BSF counter, 0, BANKED
26:            			}
27:            			divisor >>= 1;
0B58  90D8     BCF STATUS, 0, ACCESS
0B5A  3397     RRCF _this, F, BANKED
0B5C  3396     RRCF divisor, F, BANKED
28:            		} while(--counter != 0);
0B5E  2F9A     DECFSZ counter, F, BANKED
0B60  D7ED     BRA 0xB3C
29:            	}
30:            	return quotient;
0B62  C098     MOVFF counter, dividend
0B64  F094     NOP
0B66  C099     MOVFF 0x99, value
0B68  F095     NOP
31:            }
0B6A  0012     RETURN 0
---  /opt/microchip/xc8/v1.45/sources/common/itoa.c  ----------------------------------------------------
1:             #include	<stdlib.h>
2:             	
3:             char *
4:             itoa(char * buf, int val, int base)
5:             {
6:             	char *	cp = buf;
0B6C  C0A4     MOVFF buf, cp
0B6E  F0AA     NOP
0B70  C0A5     MOVFF 0xA5, 0xAB
0B72  F0AB     NOP
7:             
8:             	if(val < 0) {
0B74  0100     MOVLB 0x0
0B76  AFA7     BTFSS 0xA7, 7, BANKED
0B78  D00C     BRA 0xB92
9:             		*buf++ = '-';
0B7A  C0A4     MOVFF buf, FSR2
0B7C  FFD9     NOP
0B7E  C0A5     MOVFF 0xA5, FSR2H
0B80  FFDA     NOP
0B82  0E2D     MOVLW 0x2D
0B84  6EDF     MOVWF INDF2, ACCESS
0B86  4BA4     INFSNZ buf, F, BANKED
0B88  2BA5     INCF 0xA5, F, BANKED
10:            		val = -val;
0B8A  6DA6     NEGF val, BANKED
0B8C  1FA7     COMF 0xA7, F, BANKED
0B8E  B0D8     BTFSC STATUS, 0, ACCESS
0B90  2BA7     INCF 0xA7, F, BANKED
11:            	}
12:            	utoa(buf, val, base);
0B92  C0A4     MOVFF buf, buf
0B94  F09B     NOP
0B96  C0A5     MOVFF 0xA5, _this
0B98  F09C     NOP
0B9A  C0A6     MOVFF val, val
0B9C  F09D     NOP
0B9E  C0A7     MOVFF 0xA7, clearBuffer
0BA0  F09E     NOP
0BA2  C0A8     MOVFF base, base
0BA4  F09F     NOP
0BA6  C0A9     MOVFF 0xA9, 0xA0
0BA8  F0A0     NOP
0BAA  EC9C     CALL 0x938, 0
0BAC  F004     NOP
0BAE  0012     RETURN 0
13:            	return cp;
14:            }
15:            
16:            char *
17:            utoa(char * buf, unsigned val, int base)
18:            {
19:            	unsigned	v;
20:            	char		c;
21:            
22:            	v = val;
0938  C09D     MOVFF val, v
093A  F0A1     NOP
093C  C09E     MOVFF clearBuffer, 0xA2
093E  F0A2     NOP
23:            	do {
24:            		v /= base;
0940  C0A1     MOVFF v, dividend
0942  F094     NOP
0944  C0A2     MOVFF 0xA2, value
0946  F095     NOP
0948  C09F     MOVFF base, divisor
094A  F096     NOP
094C  C0A0     MOVFF 0xA0, _this
094E  F097     NOP
0950  EC8C     CALL 0xB18, 0
0952  F005     NOP
0954  C094     MOVFF dividend, v
0956  F0A1     NOP
0958  C095     MOVFF value, 0xA2
095A  F0A2     NOP
25:            		buf++;
095C  0100     MOVLB 0x0
095E  4B9B     INFSNZ buf, F, BANKED
0960  2B9C     INCF _this, F, BANKED
26:            	} while(v != 0);
0962  51A1     MOVF v, W, BANKED
0964  11A2     IORWF 0xA2, W, BANKED
0966  A4D8     BTFSS STATUS, 2, ACCESS
0968  D7EB     BRA 0x940
27:            	*buf-- = 0;
096A  C09B     MOVFF buf, FSR2
096C  FFD9     NOP
096E  C09C     MOVFF _this, FSR2H
0970  FFDA     NOP
0972  0E00     MOVLW 0x0
0974  6EDF     MOVWF INDF2, ACCESS
0976  079B     DECF buf, F, BANKED
0978  A0D8     BTFSS STATUS, 0, ACCESS
097A  079C     DECF _this, F, BANKED
28:            	do {
29:            		c = val % base;
097C  C09D     MOVFF val, dividend
097E  F094     NOP
0980  C09E     MOVFF clearBuffer, value
0982  F095     NOP
0984  C09F     MOVFF base, divisor
0986  F096     NOP
0988  C0A0     MOVFF 0xA0, _this
098A  F097     NOP
098C  ECD8     CALL 0xBB0, 0
098E  F005     NOP
0990  0100     MOVLB 0x0
0992  5194     MOVF dividend, W, BANKED
0994  6FA3     MOVWF c, BANKED
30:            		val /= base;
0996  C09D     MOVFF val, dividend
0998  F094     NOP
099A  C09E     MOVFF clearBuffer, value
099C  F095     NOP
099E  C09F     MOVFF base, divisor
09A0  F096     NOP
09A2  C0A0     MOVFF 0xA0, _this
09A4  F097     NOP
09A6  EC8C     CALL 0xB18, 0
09A8  F005     NOP
09AA  C094     MOVFF dividend, val
09AC  F09D     NOP
09AE  C095     MOVFF value, clearBuffer
09B0  F09E     NOP
31:            		if(c >= 10)
09B2  0E09     MOVLW 0x9
09B4  0100     MOVLB 0x0
09B6  65A3     CPFSGT c, BANKED
09B8  D002     BRA 0x9BE
32:            			c += 'A'-'0'-10;
09BA  0E07     MOVLW 0x7
09BC  27A3     ADDWF c, F, BANKED
33:            		c += '0';
09BE  0E30     MOVLW 0x30
09C0  27A3     ADDWF c, F, BANKED
34:            		*buf-- = c;
09C2  C09B     MOVFF buf, FSR2
09C4  FFD9     NOP
09C6  C09C     MOVFF _this, FSR2H
09C8  FFDA     NOP
09CA  C0A3     MOVFF c, INDF2
09CC  FFDF     NOP
09CE  079B     DECF buf, F, BANKED
09D0  A0D8     BTFSS STATUS, 0, ACCESS
09D2  079C     DECF _this, F, BANKED
35:            	} while(val != 0);
09D4  519D     MOVF val, W, BANKED
09D6  119E     IORWF clearBuffer, W, BANKED
09D8  A4D8     BTFSS STATUS, 2, ACCESS
09DA  D7D0     BRA 0x97C
36:            	return ++buf;
09DC  4B9B     INFSNZ buf, F, BANKED
09DE  2B9C     INCF _this, F, BANKED
09E0  0012     RETURN 0
37:            }
38:            
