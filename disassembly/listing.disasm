Disassembly Listing for hd_pov
Generated From:
/fred/hd_pov/dist/default/production/hd_pov.production.elf
Jan 3, 2018 7:01:05 AM

---  /opt/microchip/xc8/v1.44/sources/common/lwmod.c  ---------------------------------------------------
1:             // word unsigned modulus
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwmod(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwmod(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter;
12:            
13:            	if(divisor != 0) {
04F8  5017     MOVF divisor, W, ACCESS
04FA  1018     IORWF 0x18, W, ACCESS
04FC  B4D8     BTFSC STATUS, 2, ACCESS
04FE  D018     BRA 0x530
14:            		counter = 1;
0500  0E01     MOVLW 0x1
0502  6E19     MOVWF counter, ACCESS
15:            		while((divisor & 0x8000) == 0) {
0504  D004     BRA 0x50E
16:            			divisor <<= 1;
0506  90D8     BCF STATUS, 0, ACCESS
0508  3617     RLCF divisor, F, ACCESS
050A  3618     RLCF 0x18, F, ACCESS
17:            			counter++;
050C  2A19     INCF counter, F, ACCESS
18:            		}
050E  AE18     BTFSS 0x18, 7, ACCESS
0510  D7FA     BRA 0x506
19:            		do {
20:            			if(divisor <= dividend)
0512  5017     MOVF divisor, W, ACCESS
0514  5C15     SUBWF c, W, ACCESS
0516  5018     MOVF 0x18, W, ACCESS
0518  5816     SUBWFB s, W, ACCESS
051A  A0D8     BTFSS STATUS, 0, ACCESS
051C  D004     BRA 0x526
21:            				dividend -= divisor;
051E  5017     MOVF divisor, W, ACCESS
0520  5E15     SUBWF c, F, ACCESS
0522  5018     MOVF 0x18, W, ACCESS
0524  5A16     SUBWFB s, F, ACCESS
22:            			divisor >>= 1;
0526  90D8     BCF STATUS, 0, ACCESS
0528  3218     RRCF 0x18, F, ACCESS
052A  3217     RRCF divisor, F, ACCESS
23:            		} while(--counter != 0);
052C  2E19     DECFSZ counter, F, ACCESS
052E  D7F1     BRA 0x512
24:            	}
25:            	return dividend;
0530  C015     MOVFF c, c
0532  F015     NOP
0534  C016     MOVFF s, s
0536  F016     NOP
26:            }
0538  0012     RETURN 0
---  /opt/microchip/xc8/v1.44/sources/common/lwdiv.c  ---------------------------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwdiv(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwdiv(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned int	quotient;
12:            	unsigned char	counter;
13:            
14:            	quotient = 0;
041E  0E00     MOVLW 0x0
0420  6E1A     MOVWF 0x1A, ACCESS
0422  0E00     MOVLW 0x0
0424  6E19     MOVWF counter, ACCESS
15:            	if(divisor != 0) {
0426  5017     MOVF divisor, W, ACCESS
0428  1018     IORWF 0x18, W, ACCESS
042A  B4D8     BTFSC STATUS, 2, ACCESS
042C  D01C     BRA 0x466
16:            		counter = 1;
042E  0E01     MOVLW 0x1
0430  6E1B     MOVWF counter, ACCESS
17:            		while((divisor & 0x8000) == 0) {
0432  D004     BRA 0x43C
18:            			divisor <<= 1;
0434  90D8     BCF STATUS, 0, ACCESS
0436  3617     RLCF divisor, F, ACCESS
0438  3618     RLCF 0x18, F, ACCESS
19:            			counter++;
043A  2A1B     INCF counter, F, ACCESS
20:            		}
043C  AE18     BTFSS 0x18, 7, ACCESS
043E  D7FA     BRA 0x434
21:            		do {
22:            			quotient <<= 1;
0440  90D8     BCF STATUS, 0, ACCESS
0442  3619     RLCF counter, F, ACCESS
0444  361A     RLCF 0x1A, F, ACCESS
23:            			if(divisor <= dividend) {
0446  5017     MOVF divisor, W, ACCESS
0448  5C15     SUBWF c, W, ACCESS
044A  5018     MOVF 0x18, W, ACCESS
044C  5816     SUBWFB s, W, ACCESS
044E  A0D8     BTFSS STATUS, 0, ACCESS
0450  D005     BRA 0x45C
24:            				dividend -= divisor;
0452  5017     MOVF divisor, W, ACCESS
0454  5E15     SUBWF c, F, ACCESS
0456  5018     MOVF 0x18, W, ACCESS
0458  5A16     SUBWFB s, F, ACCESS
25:            				quotient |= 1;
045A  8019     BSF counter, 0, ACCESS
26:            			}
27:            			divisor >>= 1;
045C  90D8     BCF STATUS, 0, ACCESS
045E  3218     RRCF 0x18, F, ACCESS
0460  3217     RRCF divisor, F, ACCESS
28:            		} while(--counter != 0);
0462  2E1B     DECFSZ counter, F, ACCESS
0464  D7ED     BRA 0x440
29:            	}
30:            	return quotient;
0466  C019     MOVFF counter, c
0468  F015     NOP
046A  C01A     MOVFF 0x1A, s
046C  F016     NOP
31:            }
046E  0012     RETURN 0
---  /opt/microchip/xc8/v1.44/sources/common/itoa.c  ----------------------------------------------------
1:             #include	<stdlib.h>
2:             	
3:             char *
4:             itoa(char * buf, int val, int base)
5:             {
6:             	char *	cp = buf;
04B6  C025     MOVFF buf, cp
04B8  F02B     NOP
04BA  C026     MOVFF 0x26, 0x2C
04BC  F02C     NOP
7:             
8:             	if(val < 0) {
04BE  AE28     BTFSS 0x28, 7, ACCESS
04C0  D00C     BRA 0x4DA
9:             		*buf++ = '-';
04C2  C025     MOVFF buf, FSR2
04C4  FFD9     NOP
04C6  C026     MOVFF 0x26, FSR2H
04C8  FFDA     NOP
04CA  0E2D     MOVLW 0x2D
04CC  6EDF     MOVWF INDF2, ACCESS
04CE  4A25     INFSNZ buf, F, ACCESS
04D0  2A26     INCF 0x26, F, ACCESS
10:            		val = -val;
04D2  6C27     NEGF val, ACCESS
04D4  1E28     COMF 0x28, F, ACCESS
04D6  B0D8     BTFSC STATUS, 0, ACCESS
04D8  2A28     INCF 0x28, F, ACCESS
11:            	}
12:            	utoa(buf, val, base);
04DA  C025     MOVFF buf, buf
04DC  F01C     NOP
04DE  C026     MOVFF 0x26, 0x1D
04E0  F01D     NOP
04E2  C027     MOVFF val, val
04E4  F01E     NOP
04E6  C028     MOVFF 0x28, 0x1F
04E8  F01F     NOP
04EA  C029     MOVFF base, base
04EC  F020     NOP
04EE  C02A     MOVFF 0x2A, 0x21
04F0  F021     NOP
04F2  EC3D     CALL 0x27A, 0
04F4  F001     NOP
04F6  0012     RETURN 0
13:            	return cp;
14:            }
15:            
16:            char *
17:            utoa(char * buf, unsigned val, int base)
18:            {
19:            	unsigned	v;
20:            	char		c;
21:            
22:            	v = val;
027A  C01E     MOVFF val, v
027C  F022     NOP
027E  C01F     MOVFF 0x1F, 0x23
0280  F023     NOP
23:            	do {
24:            		v /= base;
0282  C022     MOVFF v, c
0284  F015     NOP
0286  C023     MOVFF 0x23, s
0288  F016     NOP
028A  C020     MOVFF base, divisor
028C  F017     NOP
028E  C021     MOVFF 0x21, 0x18
0290  F018     NOP
0292  EC0F     CALL 0x41E, 0
0294  F002     NOP
0296  C015     MOVFF c, v
0298  F022     NOP
029A  C016     MOVFF s, 0x23
029C  F023     NOP
25:            		buf++;
029E  4A1C     INFSNZ buf, F, ACCESS
02A0  2A1D     INCF 0x1D, F, ACCESS
26:            	} while(v != 0);
02A2  5022     MOVF v, W, ACCESS
02A4  1023     IORWF 0x23, W, ACCESS
02A6  A4D8     BTFSS STATUS, 2, ACCESS
02A8  D7EC     BRA 0x282
27:            	*buf-- = 0;
02AA  C01C     MOVFF buf, FSR2
02AC  FFD9     NOP
02AE  C01D     MOVFF 0x1D, FSR2H
02B0  FFDA     NOP
02B2  0E00     MOVLW 0x0
02B4  6EDF     MOVWF INDF2, ACCESS
02B6  061C     DECF buf, F, ACCESS
02B8  A0D8     BTFSS STATUS, 0, ACCESS
02BA  061D     DECF 0x1D, F, ACCESS
28:            	do {
29:            		c = val % base;
02BC  C01E     MOVFF val, c
02BE  F015     NOP
02C0  C01F     MOVFF 0x1F, s
02C2  F016     NOP
02C4  C020     MOVFF base, divisor
02C6  F017     NOP
02C8  C021     MOVFF 0x21, 0x18
02CA  F018     NOP
02CC  EC7C     CALL 0x4F8, 0
02CE  F002     NOP
02D0  5015     MOVF c, W, ACCESS
02D2  6E24     MOVWF c, ACCESS
30:            		val /= base;
02D4  C01E     MOVFF val, c
02D6  F015     NOP
02D8  C01F     MOVFF 0x1F, s
02DA  F016     NOP
02DC  C020     MOVFF base, divisor
02DE  F017     NOP
02E0  C021     MOVFF 0x21, 0x18
02E2  F018     NOP
02E4  EC0F     CALL 0x41E, 0
02E6  F002     NOP
02E8  C015     MOVFF c, val
02EA  F01E     NOP
02EC  C016     MOVFF s, 0x1F
02EE  F01F     NOP
31:            		if(c >= 10)
02F0  0E09     MOVLW 0x9
02F2  6424     CPFSGT c, ACCESS
02F4  D002     BRA 0x2FA
32:            			c += 'A'-'0'-10;
02F6  0E07     MOVLW 0x7
02F8  2624     ADDWF c, F, ACCESS
33:            		c += '0';
02FA  0E30     MOVLW 0x30
02FC  2624     ADDWF c, F, ACCESS
34:            		*buf-- = c;
02FE  C01C     MOVFF buf, FSR2
0300  FFD9     NOP
0302  C01D     MOVFF 0x1D, FSR2H
0304  FFDA     NOP
0306  C024     MOVFF c, INDF2
0308  FFDF     NOP
030A  061C     DECF buf, F, ACCESS
030C  A0D8     BTFSS STATUS, 0, ACCESS
030E  061D     DECF 0x1D, F, ACCESS
35:            	} while(val != 0);
0310  501E     MOVF val, W, ACCESS
0312  101F     IORWF 0x1F, W, ACCESS
0314  A4D8     BTFSS STATUS, 2, ACCESS
0316  D7D2     BRA 0x2BC
36:            	return ++buf;
0318  4A1C     INFSNZ buf, F, ACCESS
031A  2A1D     INCF 0x1D, F, ACCESS
031C  0012     RETURN 0
37:            }
38:            
---  /fred/hd_pov/pat.c  --------------------------------------------------------------------------------
1:             // HD POV Version for XC8
2:             // PIC18F1320 Configuration Bit Settings 
3:             
4:             // CONFIG1H
5:             #pragma config OSC = HSPLL      // Oscillator Selection bits 40MHz fosc with PLL and 10MHz clock input
6:             #pragma config FSCM = ON        // Fail-Safe Clock Monitor Enable bit (Fail-Safe Clock Monitor enabled)
7:             #pragma config IESO = ON        // Internal External Switchover bit (Internal External Switchover mode enabled)
8:             
9:             // CONFIG2L
10:            #pragma config PWRT = OFF       // Power-up Timer Enable bit (PWRT disabled)
11:            #pragma config BOR = ON         // Brown-out Reset Enable bit (Brown-out Reset enabled)
12:            // BORV = No Setting
13:            
14:            // CONFIG2H
15:            #pragma config WDT = ON        // Watchdog Timer Enable bit 
16:            #pragma config WDTPS = 4096    // Watchdog Timer Postscale Select bits 
17:            
18:            // CONFIG3H
19:            #pragma config MCLRE = ON       // MCLR Pin Enable bit (MCLR pin enabled, RA5 input pin disabled)
20:            
21:            // CONFIG4L
22:            #pragma config STVR = ON        // Stack Full/Underflow Reset Enable bit (Stack full/underflow will cause Reset)
23:            #pragma config LVP = OFF        // Low-Voltage ICSP Enable bit (Low-Voltage ICSP disabled)
24:            
25:            // CONFIG5L
26:            #pragma config CP0 = ON        // Code Protection bit (Block 0 (00200-000FFFh) not code-protected)
27:            #pragma config CP1 = ON        // Code Protection bit (Block 1 (001000-001FFFh) not code-protected)
28:            
29:            // CONFIG5H
30:            #pragma config CPB = OFF        // Boot Block Code Protection bit (Boot Block (000000-0001FFh) not code-protected)
31:            #pragma config CPD = OFF        // Data EEPROM Code Protection bit (Data EEPROM not code-protected)
32:            
33:            // CONFIG6L
34:            #pragma config WRT0 = OFF       // Write Protection bit (Block 0 (00200-000FFFh) not write-protected)
35:            #pragma config WRT1 = OFF       // Write Protection bit (Block 1 (001000-001FFFh) not write-protected)
36:            
37:            // CONFIG6H
38:            #pragma config WRTC = OFF       // Configuration Register Write Protection bit (Configuration registers (300000-3000FFh) not write-protected)
39:            #pragma config WRTB = OFF       // Boot Block Write Protection bit (Boot Block (000000-0001FFh) not write-protected)
40:            #pragma config WRTD = OFF       // Data EEPROM Write Protection bit (Data EEPROM not write-protected)
41:            
42:            // CONFIG7L
43:            #pragma config EBTR0 = OFF      // Table Read Protection bit (Block 0 (00200-000FFFh) not protected from table reads executed in other blocks)
44:            #pragma config EBTR1 = OFF      // Table Read Protection bit (Block 1 (001000-001FFFh) not protected from table reads executed in other blocks)
45:            
46:            // CONFIG7H
47:            #pragma config EBTRB = OFF      // Boot Block Table Read Protection bit (Boot Block (000000-0001FFh) not protected from table reads executed in other blocks)
48:            
49:            
50:            /*
51:             * Driver for hard-drive strobe for POV demo
52:             * Versions
53:             * 1.0 RGB support
54:             */
55:            
56:            #include  <xc.h>
57:            #include <stdlib.h>
58:            #include <stdio.h>
59:            #include "pat.h"
60:            #include <string.h>
61:            
62:            int16_t sw_work(void);
63:            void init_rmsmon(void);
64:            uint8_t init_rms_params(void);
65:            
66:            uint8_t str[24];
67:            near volatile struct L_data *L_ptr;
68:            near volatile struct V_data V;
69:            volatile uint16_t timer0_off = TIMEROFFSET, timer1_off = SAMPLEFREQ;
70:            near volatile struct L_data L[2];
71:            volatile uint8_t l_state = 2;
72:            volatile uint16_t l_full = strobe_limit_l;
73:            
74:            static const uint8_t build_date[] = __DATE__, build_time[] = __TIME__;
75:            static const uint8_t versions[]="1.0";
76:            
77:            void interrupt high_priority tm_handler(void) // timer/serial functions are handled here
78:            {
79:            
80:            	if (INTCONbits.INT0IF) { // Hall effect index signal, start of rotation
0052  A2F2     BTFSS INTCON, 1, ACCESS
0054  D069     BRA 0x128
81:            		INTCONbits.INT0IF = FALSE;
0056  92F2     BCF INTCON, 1, ACCESS
82:            		RPMLED = (uint8_t)!RPMLED;
0058  BA8A     BTFSC LATB, 5, ACCESS
005A  D003     BRA 0x62
005C  6A01     CLRF __pcstackCOMRAM, ACCESS
005E  2A01     INCF __pcstackCOMRAM, F, ACCESS
0060  D001     BRA 0x64
0062  6A01     CLRF __pcstackCOMRAM, ACCESS
0064  3A01     SWAPF __pcstackCOMRAM, F, ACCESS
0066  4601     RLNCF __pcstackCOMRAM, F, ACCESS
0068  508A     MOVF LATB, W, ACCESS
006A  1801     XORWF __pcstackCOMRAM, W, ACCESS
006C  0BDF     ANDLW 0xDF
006E  1801     XORWF __pcstackCOMRAM, W, ACCESS
0070  6E8A     MOVWF LATB, ACCESS
83:            		if (l_state == 1) { // off state too long for full rotation, hall signal while in state 1
0072  045E     DECF l_state, W, ACCESS
0074  A4D8     BTFSS STATUS, 2, ACCESS
0076  D004     BRA 0x80
84:            			l_full += strobe_adjust; // off state lower limit adjustments for smooth strobe rotation
0078  0E0B     MOVLW 0xB
007A  2658     ADDWF l_full, F, ACCESS
007C  0E00     MOVLW 0x0
007E  2259     ADDWFC 0x59, F, ACCESS
85:            		}
86:            		l_state = 0; // restart lamp flashing sequence, off time
0080  0E00     MOVLW 0x0
0082  6E5E     MOVWF l_state, ACCESS
87:            
88:            		L_ptr = &L[V.line_num]; // select line strobe data
0084  A42F     BTFSS 0x2F, 2, ACCESS
0086  D003     BRA 0x8E
0088  6A01     CLRF __pcstackCOMRAM, ACCESS
008A  2A01     INCF __pcstackCOMRAM, F, ACCESS
008C  D001     BRA 0x90
008E  6A01     CLRF __pcstackCOMRAM, ACCESS
0090  5001     MOVF __pcstackCOMRAM, W, ACCESS
0092  0D06     MULLW 0x6
0094  0E4C     MOVLW 0x4C
0096  24F3     ADDWF PROD, W, ACCESS
0098  6E32     MOVWF L_ptr, ACCESS
009A  0E00     MOVLW 0x0
009C  20F4     ADDWFC PRODH, W, ACCESS
009E  6E33     MOVWF 0x33, ACCESS
89:            
90:            		/* limit rotational timer values */
91:            		switch (V.line_num) {
00A0  D036     BRA 0x10E
010E  A42F     BTFSS 0x2F, 2, ACCESS
0110  D002     BRA 0x116
0112  0E01     MOVLW 0x1
0114  D001     BRA 0x118
0116  0E00     MOVLW 0x0
0118  0A00     XORLW 0x0
011A  B4D8     BTFSC STATUS, 2, ACCESS
011C  D7C2     BRA 0xA2
011E  0A01     XORLW 0x1
0120  B4D8     BTFSC STATUS, 2, ACCESS
0122  D7DA     BRA 0xD8
0124  D7BE     BRA 0xA2
92:            		case 0:
93:            			L_ptr->strobe[0] -= strobe_down; // start sliding the positions
00A2  0E1F     MOVLW 0x1F
00A4  C032     MOVFF L_ptr, FSR2
00A6  FFD9     NOP
00A8  C033     MOVFF 0x33, FSR2H
00AA  FFDA     NOP
00AC  5EDE     SUBWF POSTINC2, F, ACCESS
00AE  0E00     MOVLW 0x0
00B0  5ADD     SUBWFB POSTDEC2, F, ACCESS
94:            			if (L_ptr->strobe[0] < l_full)
00B2  C032     MOVFF L_ptr, FSR2
00B4  FFD9     NOP
00B6  C033     MOVFF 0x33, FSR2H
00B8  FFDA     NOP
00BA  5058     MOVF l_full, W, ACCESS
00BC  5CDE     SUBWF POSTINC2, W, ACCESS
00BE  5059     MOVF 0x59, W, ACCESS
00C0  58DE     SUBWFB POSTINC2, W, ACCESS
00C2  B0D8     BTFSC STATUS, 0, ACCESS
00C4  D030     BRA 0x126
95:            				L_ptr->strobe[0] = strobe_limit_h; // set to upper limit rollover
00C6  C032     MOVFF L_ptr, FSR2
00C8  FFD9     NOP
00CA  C033     MOVFF 0x33, FSR2H
00CC  FFDA     NOP
00CE  0EFA     MOVLW 0xFA
00D0  6EDE     MOVWF POSTINC2, ACCESS
00D2  0EFF     MOVLW 0xFF
00D4  6EDD     MOVWF POSTDEC2, ACCESS
96:            			break;
00D6  D027     BRA 0x126
97:            		case 1:
98:            			L_ptr->strobe[0] += strobe_up;
00D8  0E43     MOVLW 0x43
00DA  C032     MOVFF L_ptr, FSR2
00DC  FFD9     NOP
00DE  C033     MOVFF 0x33, FSR2H
00E0  FFDA     NOP
00E2  26DE     ADDWF POSTINC2, F, ACCESS
00E4  0E00     MOVLW 0x0
00E6  22DD     ADDWFC POSTDEC2, F, ACCESS
99:            			if (L_ptr->strobe[0] < l_full)
00E8  C032     MOVFF L_ptr, FSR2
00EA  FFD9     NOP
00EC  C033     MOVFF 0x33, FSR2H
00EE  FFDA     NOP
00F0  5058     MOVF l_full, W, ACCESS
00F2  5CDE     SUBWF POSTINC2, W, ACCESS
00F4  5059     MOVF 0x59, W, ACCESS
00F6  58DE     SUBWFB POSTINC2, W, ACCESS
00F8  B0D8     BTFSC STATUS, 0, ACCESS
00FA  D015     BRA 0x126
100:           				L_ptr->strobe[0] = l_full; // set to sliding lower limit
00FC  C032     MOVFF L_ptr, FSR2
00FE  FFD9     NOP
0100  C033     MOVFF 0x33, FSR2H
0102  FFDA     NOP
0104  C058     MOVFF l_full, POSTINC2
0106  FFDE     NOP
0108  C059     MOVFF 0x59, POSTDEC2
010A  FFDD     NOP
101:           			break;
010C  D00C     BRA 0x126
102:           		default:
103:           			L_ptr->strobe[0] -= strobe_down;
104:           			if (L_ptr->strobe[0] < l_full)
105:           				L_ptr->strobe[0] = strobe_limit_h;
106:           			break;
107:           		}
108:           
109:           		V.line_num++;
0126  742F     BTG 0x2F, 2, ACCESS
110:           	}
111:           
112:           	if (PIR1bits.TMR1IF || l_state == 0) { //      Timer1 int handler, for strobe timing
0128  B09E     BTFSC PIR1, 0, ACCESS
012A  D003     BRA 0x132
012C  505E     MOVF l_state, W, ACCESS
012E  A4D8     BTFSS STATUS, 2, ACCESS
0130  D044     BRA 0x1BA
113:           		PIR1bits.TMR1IF = FALSE;
0132  909E     BCF PIR1, 0, ACCESS
114:           		WRITETIMER1(L_ptr->strobe[l_state]); // strobe positioning during rotation
0134  505E     MOVF l_state, W, ACCESS
0136  0D02     MULLW 0x2
0138  50F3     MOVF PROD, W, ACCESS
013A  2432     ADDWF L_ptr, W, ACCESS
013C  6ED9     MOVWF FSR2, ACCESS
013E  50F4     MOVF PRODH, W, ACCESS
0140  2033     ADDWFC 0x33, W, ACCESS
0142  6EDA     MOVWF FSR2H, ACCESS
0144  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
0146  F001     NOP
0148  CFDD     MOVFF POSTDEC2, 0x2
014A  F002     NOP
014C  C002     MOVFF 0x2, __pcstackCOMRAM
014E  F001     NOP
0150  6A02     CLRF 0x2, ACCESS
0152  5001     MOVF __pcstackCOMRAM, W, ACCESS
0154  6ECF     MOVWF TMR1H, ACCESS
0156  505E     MOVF l_state, W, ACCESS
0158  0D02     MULLW 0x2
015A  50F3     MOVF PROD, W, ACCESS
015C  2432     ADDWF L_ptr, W, ACCESS
015E  6ED9     MOVWF FSR2, ACCESS
0160  50F4     MOVF PRODH, W, ACCESS
0162  2033     ADDWFC 0x33, W, ACCESS
0164  6EDA     MOVWF FSR2H, ACCESS
0166  50DF     MOVF INDF2, W, ACCESS
0168  6ECE     MOVWF TMR1, ACCESS
115:           
116:           		switch (l_state) {
016A  D01E     BRA 0x1A8
01A8  505E     MOVF l_state, W, ACCESS
01AA  0A00     XORLW 0x0
01AC  B4D8     BTFSC STATUS, 2, ACCESS
01AE  D7DE     BRA 0x16C
01B0  0A01     XORLW 0x1
01B2  B4D8     BTFSC STATUS, 2, ACCESS
01B4  D7E6     BRA 0x182
01B6  0A03     XORLW 0x3
01B8  D7F3     BRA 0x1A0
117:           		case 0:
118:           			G_OUT = 0;
016C  9089     BCF LATA, 0, ACCESS
119:           			R_OUT = 0;
016E  9289     BCF LATA, 1, ACCESS
120:           			B_OUT = 0;
0170  9489     BCF LATA, 2, ACCESS
121:           			l_state = 1; // off time after index to start time
0172  0E01     MOVLW 0x1
0174  D013     BRA 0x19C
122:           			break;
123:           		case 1:
124:           			switch (V.line_num) {
0182  A42F     BTFSS 0x2F, 2, ACCESS
0184  D002     BRA 0x18A
0186  0E01     MOVLW 0x1
0188  D001     BRA 0x18C
018A  0E00     MOVLW 0x0
018C  0A00     XORLW 0x0
018E  B4D8     BTFSC STATUS, 2, ACCESS
0190  D7F2     BRA 0x176
0192  0A01     XORLW 0x1
0194  B4D8     BTFSC STATUS, 2, ACCESS
0196  D7F1     BRA 0x17A
0198  D7F2     BRA 0x17E
125:           			case 0:
126:           				G_OUT = 1;
0176  8089     BSF LATA, 0, ACCESS
127:           				break;
0178  D010     BRA 0x19A
128:           			case 1:
129:           				R_OUT = 1;
017A  8289     BSF LATA, 1, ACCESS
130:           				break;
017C  D00E     BRA 0x19A
131:           			default:
132:           				B_OUT = 1;
017E  8489     BSF LATA, 2, ACCESS
133:           				break;
134:           			}
0180  D00C     BRA 0x19A
135:           
136:           			l_state = 2; // on start time duration for strobe pulse
019A  0E02     MOVLW 0x2
019C  6E5E     MOVWF l_state, ACCESS
137:           			break;
019E  D00D     BRA 0x1BA
138:           		case 2:
139:           			G_OUT = 0; // wait to next rotation
140:           			R_OUT = 0;
141:           			B_OUT = 0;
142:           			break;
143:           		default:
144:           			G_OUT = 0;
01A0  9089     BCF LATA, 0, ACCESS
145:           			R_OUT = 0;
01A2  9289     BCF LATA, 1, ACCESS
146:           			B_OUT = 0;
01A4  9489     BCF LATA, 2, ACCESS
147:           			break;
148:           		}
01A6  D009     BRA 0x1BA
149:           	}
150:           
151:           	if (PIR1bits.RCIF) { // is data from RS-232 port
01BA  AA9E     BTFSS PIR1, 5, ACCESS
01BC  D007     BRA 0x1CC
152:           		V.rx_data = RCREG;
01BE  CFAE     MOVFF RCREG, 0x30
01C0  F030     NOP
153:           		if (RCSTAbits.OERR) {
01C2  A2AB     BTFSS RCSTA, 1, ACCESS
01C4  D002     BRA 0x1CA
154:           			RCSTAbits.CREN = 0; // clear overrun
01C6  98AB     BCF RCSTA, 4, ACCESS
155:           			RCSTAbits.CREN = 1; // re-enable
01C8  88AB     BSF RCSTA, 4, ACCESS
156:           		}
157:           		V.comm = TRUE;
01CA  822D     BSF V, 1, ACCESS
158:           	}
159:           
160:           
161:           	if (INTCONbits.TMR0IF) { //      check timer0 
01CC  A4F2     BTFSS INTCON, 2, ACCESS
01CE  D012     BRA 0x1F4
162:           		INTCONbits.TMR0IF = FALSE; //      clear interrupt flag
01D0  94F2     BCF INTCON, 2, ACCESS
163:           		WRITETIMER0(timer0_off);
01D2  505D     MOVF 0x5D, W, ACCESS
01D4  6ED7     MOVWF TMR0H, ACCESS
01D6  C05C     MOVFF timer0_off, TMR0
01D8  FFD6     NOP
164:           		LED5 = (uint8_t)!LED5; // active LED blinker
01DA  BE8A     BTFSC LATB, 7, ACCESS
01DC  D003     BRA 0x1E4
01DE  6A01     CLRF __pcstackCOMRAM, ACCESS
01E0  2A01     INCF __pcstackCOMRAM, F, ACCESS
01E2  D001     BRA 0x1E6
01E4  6A01     CLRF __pcstackCOMRAM, ACCESS
01E6  3201     RRCF __pcstackCOMRAM, F, ACCESS
01E8  3201     RRCF __pcstackCOMRAM, F, ACCESS
01EA  508A     MOVF LATB, W, ACCESS
01EC  1801     XORWF __pcstackCOMRAM, W, ACCESS
01EE  0B7F     ANDLW 0x7F
01F0  1801     XORWF __pcstackCOMRAM, W, ACCESS
01F2  6E8A     MOVWF LATB, ACCESS
165:           	}
166:           
167:           }
01F4  C014     MOVFF 0x14, 0x62
168:           
169:           void USART_putc(unsigned char c)
05C2  6E15     MOVWF c, ACCESS
170:           {
171:           	while (!TXSTAbits.TRMT);
05C4  A2AC     BTFSS TXSTA, 1, ACCESS
05C6  D7FE     BRA 0x5C4
172:           	TXREG = c;
05C8  C015     MOVFF c, TXREG
05CA  FFAD     NOP
173:           }
05CC  0012     RETURN 0
174:           
175:           void USART_puts(unsigned char *s)
176:           {
177:           	while (*s) {
059E  D009     BRA 0x5B2
178:           		USART_putc(*s);
05A0  C016     MOVFF s, FSR2
05A2  FFD9     NOP
05A4  C017     MOVFF divisor, FSR2H
05A6  FFDA     NOP
05A8  50DF     MOVF INDF2, W, ACCESS
05AA  ECE1     CALL 0x5C2, 0
05AC  F002     NOP
179:           		s++;
05AE  4A16     INFSNZ s, F, ACCESS
05B0  2A17     INCF divisor, F, ACCESS
180:           	}
05B2  C016     MOVFF s, FSR2
05B4  FFD9     NOP
05B6  C017     MOVFF divisor, FSR2H
05B8  FFDA     NOP
05BA  50DF     MOVF INDF2, W, ACCESS
05BC  B4D8     BTFSC STATUS, 2, ACCESS
05BE  0012     RETURN 0
05C0  D7EF     BRA 0x5A0
181:           }
182:           
183:           void USART_putsr(const unsigned char *s)
184:           {
185:           	while (*s) {
0574  D00A     BRA 0x58A
186:           		USART_putc(*s);
0576  C016     MOVFF s, TBLPTR
0578  FFF6     NOP
057A  C017     MOVFF divisor, TBLPTRH
057C  FFF7     NOP
057E  0008     TBLRD*
0580  50F5     MOVF TABLAT, W, ACCESS
0582  ECE1     CALL 0x5C2, 0
0584  F002     NOP
187:           		s++;
0586  4A16     INFSNZ s, F, ACCESS
0588  2A17     INCF divisor, F, ACCESS
188:           	}
058A  C016     MOVFF s, TBLPTR
058C  FFF6     NOP
058E  C017     MOVFF divisor, TBLPTRH
0590  FFF7     NOP
0592  0008     TBLRD*
0594  50F5     MOVF TABLAT, W, ACCESS
0596  0900     IORLW 0x0
0598  B4D8     BTFSC STATUS, 2, ACCESS
059A  0012     RETURN 0
059C  D7EC     BRA 0x576
189:           }
190:           
191:           /* main loop routine */
192:           int16_t sw_work(void)
193:           {
194:           	ClrWdt(); // reset watchdog
03A0  0004     CLRWDT
195:           
196:           	if (!SW1) {
03A2  B880     BTFSC PORTA, 4, ACCESS
03A4  D03A     BRA 0x41A
197:           		USART_putsr("Timer limit ");
03A6  0E6B     MOVLW 0x6B
03A8  6E16     MOVWF s, ACCESS
03AA  0E02     MOVLW 0x2
03AC  6E17     MOVWF divisor, ACCESS
03AE  ECBA     CALL 0x574, 0
03B0  F002     NOP
198:           		itoa(str, l_full, 10);
03B2  0E34     MOVLW 0x34
03B4  6E25     MOVWF buf, ACCESS
03B6  0E00     MOVLW 0x0
03B8  6E26     MOVWF 0x26, ACCESS
03BA  C058     MOVFF l_full, val
03BC  F027     NOP
03BE  C059     MOVFF 0x59, 0x28
03C0  F028     NOP
03C2  0E00     MOVLW 0x0
03C4  6E2A     MOVWF 0x2A, ACCESS
03C6  0E0A     MOVLW 0xA
03C8  6E29     MOVWF base, ACCESS
03CA  EC5B     CALL 0x4B6, 0
03CC  F002     NOP
199:           		USART_puts(str);
03CE  0E34     MOVLW 0x34
03D0  6E16     MOVWF s, ACCESS
03D2  0E00     MOVLW 0x0
03D4  6E17     MOVWF divisor, ACCESS
03D6  ECCF     CALL 0x59E, 0
03D8  F002     NOP
200:           		USART_putsr("Timer value ");
03DA  0E5E     MOVLW 0x5E
03DC  6E16     MOVWF s, ACCESS
03DE  0E02     MOVLW 0x2
03E0  6E17     MOVWF divisor, ACCESS
03E2  ECBA     CALL 0x574, 0
03E4  F002     NOP
201:           		itoa(str, L_ptr->strobe[0], 10);
03E6  0E34     MOVLW 0x34
03E8  6E25     MOVWF buf, ACCESS
03EA  0E00     MOVLW 0x0
03EC  6E26     MOVWF 0x26, ACCESS
03EE  C032     MOVFF L_ptr, FSR2
03F0  FFD9     NOP
03F2  C033     MOVFF 0x33, FSR2H
03F4  FFDA     NOP
03F6  CFDE     MOVFF POSTINC2, val
03F8  F027     NOP
03FA  CFDD     MOVFF POSTDEC2, 0x28
03FC  F028     NOP
03FE  0E00     MOVLW 0x0
0400  6E2A     MOVWF 0x2A, ACCESS
0402  0E0A     MOVLW 0xA
0404  6E29     MOVWF base, ACCESS
0406  EC5B     CALL 0x4B6, 0
0408  F002     NOP
202:           		USART_puts(str);
040A  0E34     MOVLW 0x34
040C  6E16     MOVWF s, ACCESS
040E  0E00     MOVLW 0x0
0410  6E17     MOVWF divisor, ACCESS
0412  ECCF     CALL 0x59E, 0
0414  F002     NOP
203:           		LED1 = 1;
0416  8689     BSF LATA, 3, ACCESS
204:           	} else {
0418  0012     RETURN 0
205:           		LED1 = 0;
041A  9689     BCF LATA, 3, ACCESS
041C  0012     RETURN 0
206:           	}
207:           
208:           	return 0;
209:           }
210:           
211:           void init_rmsmon(void)
212:           {
213:           	/*
214:           	 * check for a clean POR
215:           	 */
216:           	V.boot_code = FALSE;
031E  922F     BCF 0x2F, 1, ACCESS
217:           	if (RCON != 0b0011100)
0320  0E1C     MOVLW 0x1C
0322  18D0     XORWF RCON, W, ACCESS
0324  A4D8     BTFSS STATUS, 2, ACCESS
218:           		V.boot_code = TRUE;
0326  822F     BSF 0x2F, 1, ACCESS
219:           
220:           	if (STKPTRbits.STKFUL || STKPTRbits.STKUNF) {
0328  BEFC     BTFSC STKPTR, 7, ACCESS
032A  D002     BRA 0x330
032C  ACFC     BTFSS STKPTR, 6, ACCESS
032E  D003     BRA 0x336
221:           		V.boot_code = TRUE;
0330  822F     BSF 0x2F, 1, ACCESS
222:           		STKPTRbits.STKFUL = 0;
0332  9EFC     BCF STKPTR, 7, ACCESS
223:           		STKPTRbits.STKUNF = 0;
0334  9CFC     BCF STKPTR, 6, ACCESS
224:           	}
225:           
226:           	ADCON1 = 0x7F; // all digital, no ADC
0336  0E7F     MOVLW 0x7F
0338  6EC1     MOVWF ADCON1, ACCESS
227:           	/* interrupt priority ON */
228:           	RCONbits.IPEN = 1;
033A  8ED0     BSF RCON, 7, ACCESS
229:           	/* define I/O ports */
230:           	RMSPORTA = RMSPORT_IOA;
033C  0E10     MOVLW 0x10
033E  6E92     MOVWF TRISA, ACCESS
231:           	RMSPORTB = RMSPORT_IOB;
0340  0E11     MOVLW 0x11
0342  6E93     MOVWF TRISB, ACCESS
232:           
233:           	G_OUT = LEDON; // preset all LEDS
0344  9089     BCF LATA, 0, ACCESS
234:           	LED1 = LEDON;
0346  9689     BCF LATA, 3, ACCESS
235:           	LED2 = LEDON;
0348  9689     BCF LATA, 3, ACCESS
236:           	LED3 = LEDON;
034A  9689     BCF LATA, 3, ACCESS
237:           	LED4 = LEDON;
034C  9C8A     BCF LATB, 6, ACCESS
238:           	LED5 = LEDON;
034E  9E8A     BCF LATB, 7, ACCESS
239:           	LED6 = LEDON;
0350  9C89     BCF LATA, 6, ACCESS
240:           	RPMLED = LEDON;
0352  9A8A     BCF LATB, 5, ACCESS
241:           	timer0_off = TIMEROFFSET; // blink fast
0354  0E46     MOVLW 0x46
0356  6E5D     MOVWF 0x5D, ACCESS
0358  0E50     MOVLW 0x50
035A  6E5C     MOVWF timer0_off, ACCESS
242:           	//	OpenTimer0(TIMER_INT_ON & T0_16BIT & T0_SOURCE_INT & T0_PS_1_256); // led blinker
243:           	T0CON = 0b10000111;
035C  0E87     MOVLW 0x87
035E  6ED5     MOVWF T0CON, ACCESS
244:           	WRITETIMER0(timer0_off); //	start timer0 at ~1/2 second ticks
0360  505D     MOVF 0x5D, W, ACCESS
0362  6ED7     MOVWF TMR0H, ACCESS
0364  C05C     MOVFF timer0_off, TMR0
0366  FFD6     NOP
245:           	//	OpenTimer1(TIMER_INT_ON & T1_16BIT_RW & T1_SOURCE_INT & T1_PS_1_2 & T1_OSC1EN_OFF & T1_SYNC_EXT_OFF); // strobe position clock
246:           	T1CON = 0b10010101;
0368  0E95     MOVLW 0x95
036A  6ECD     MOVWF T1CON, ACCESS
247:           	WRITETIMER1(timer1_off);
036C  505B     MOVF 0x5B, W, ACCESS
036E  6ECF     MOVWF TMR1H, ACCESS
0370  C05A     MOVFF timer1_off, TMR1
0372  FFCE     NOP
248:           	/* data link */
249:           	COMM_ENABLE = TRUE; // for PICDEM4 onboard RS-232, not used on custom board
0374  868A     BSF LATB, 3, ACCESS
250:           	TXSTAbits.TXEN = 1;
0376  8AAC     BSF TXSTA, 5, ACCESS
251:           	RCSTAbits.CREN = 1;
0378  88AB     BSF RCSTA, 4, ACCESS
252:           	RCSTAbits.SPEN = 1;
037A  8EAB     BSF RCSTA, 7, ACCESS
253:           	TXSTAbits.SYNC = 0;
037C  98AC     BCF TXSTA, 4, ACCESS
254:           	TXSTAbits.SYNC = 0;
037E  98AC     BCF TXSTA, 4, ACCESS
255:           	TXSTAbits.BRGH = 0;
0380  94AC     BCF TXSTA, 2, ACCESS
256:           	BAUDCTLbits.BRG16 = 0;
0382  96AA     BCF BAUDCTL, 3, ACCESS
257:           	SPBRG = 64;
0384  0E40     MOVLW 0x40
0386  6EAF     MOVWF SPBRG, ACCESS
258:           
259:           	/*      work int thread setup */
260:           	INTCONbits.TMR0IE = 1; // enable int
0388  8AF2     BSF INTCON, 5, ACCESS
261:           	INTCON2bits.TMR0IP = 1; // make it high P
038A  84F1     BSF INTCON2, 2, ACCESS
262:           
263:           	PIE1bits.TMR1IE = 1;
038C  809D     BSF PIE1, 0, ACCESS
264:           	IPR1bits.TMR1IP = 1;
038E  809F     BSF IPR1, 0, ACCESS
265:           
266:           	INTCONbits.INT0IE = 1; // enable RPM sensor input
0390  88F2     BSF INTCON, 4, ACCESS
267:           	INTCON2bits.RBPU = 0; // enable weak pull-ups
0392  9EF1     BCF INTCON2, 7, ACCESS
268:           
269:           	PIE1bits.RCIE = 1; // enable rs232 serial receive interrupts
0394  8A9D     BSF PIE1, 5, ACCESS
270:           	IPR1bits.RCIP = 1;
0396  8A9F     BSF IPR1, 5, ACCESS
271:           
272:           	init_rms_params();
0398  EC38     CALL 0x470, 0
039A  F002     NOP
273:           
274:           	/* Enable all high priority interrupts */
275:           	INTCONbits.GIEH = 1;
039C  8EF2     BSF INTCON, 7, ACCESS
276:           }
039E  0012     RETURN 0
277:           
278:           uint8_t init_rms_params(void)
279:           {
280:           	V.spinning = FALSE;
0470  902F     BCF 0x2F, 0, ACCESS
281:           	V.valid = TRUE;
0472  802D     BSF V, 0, ACCESS
282:           	V.comm = FALSE;
0474  922D     BCF V, 1, ACCESS
283:           	V.comm_state = 0;
0476  0E00     MOVLW 0x0
0478  6E2E     MOVWF 0x2E, ACCESS
284:           	V.line_num = 0;
047A  942F     BCF 0x2F, 2, ACCESS
285:           
286:           	L_ptr = &L[0];
047C  0E4C     MOVLW 0x4C
047E  6E32     MOVWF L_ptr, ACCESS
0480  0E00     MOVLW 0x0
0482  6E33     MOVWF 0x33, ACCESS
287:           	/* two line strobes in 3 16-bit timer values for spacing */
288:           	/* for an interrupt driven state machine */
289:           	L[0].strobe[0] = 60000;
0484  0EEA     MOVLW 0xEA
0486  6E4D     MOVWF 0x4D, ACCESS
0488  0E60     MOVLW 0x60
048A  6E4C     MOVWF L, ACCESS
290:           	L[0].strobe[1] = 64900;
048C  0EFD     MOVLW 0xFD
048E  6E4F     MOVWF 0x4F, ACCESS
0490  0E84     MOVLW 0x84
0492  6E4E     MOVWF 0x4E, ACCESS
291:           	L[0].strobe[2] = 10000;
0494  0E27     MOVLW 0x27
0496  6E51     MOVWF 0x51, ACCESS
0498  0E10     MOVLW 0x10
049A  6E50     MOVWF 0x50, ACCESS
292:           	L[1].strobe[0] = 50000; // 62000
049C  0EC3     MOVLW 0xC3
049E  6E53     MOVWF 0x53, ACCESS
04A0  0E50     MOVLW 0x50
04A2  6E52     MOVWF 0x52, ACCESS
293:           	L[1].strobe[1] = 64900;
04A4  0EFD     MOVLW 0xFD
04A6  6E55     MOVWF 0x55, ACCESS
04A8  0E84     MOVLW 0x84
04AA  6E54     MOVWF 0x54, ACCESS
294:           	L[1].strobe[2] = 10000;
04AC  0E27     MOVLW 0x27
04AE  6E57     MOVWF 0x57, ACCESS
04B0  0E10     MOVLW 0x10
04B2  6E56     MOVWF 0x56, ACCESS
04B4  0012     RETURN 0
295:           	return 0;
296:           }
0008  825F     BSF btemp, 1, ACCESS
000A  CFFA     MOVFF PCLATH, 0x3
000C  F003     NOP
000E  CFFB     MOVFF PCLATU, 0x4
0010  F004     NOP
0012  CFE9     MOVFF FSR0, 0x5
0014  F005     NOP
0016  CFEA     MOVFF FSR0H, 0x6
0018  F006     NOP
001A  CFE1     MOVFF FSR1, 0x7
001C  F007     NOP
001E  CFE2     MOVFF FSR1H, 0x8
0020  F008     NOP
0022  CFD9     MOVFF FSR2, 0x9
0024  F009     NOP
0026  CFDA     MOVFF FSR2H, 0xA
0028  F00A     NOP
002A  CFF3     MOVFF PROD, 0xB
002C  F00B     NOP
002E  CFF4     MOVFF PRODH, 0xC
0030  F00C     NOP
0032  CFF6     MOVFF TBLPTR, 0xD
0034  F00D     NOP
0036  CFF7     MOVFF TBLPTRH, 0xE
0038  F00E     NOP
003A  CFF8     MOVFF TBLPTRU, 0xF
003C  F00F     NOP
003E  CFF5     MOVFF TABLAT, 0x10
0040  F010     NOP
0042  C05F     MOVFF btemp, 0x11
0044  F011     NOP
0046  C060     MOVFF 0x60, 0x12
0048  F012     NOP
004A  C061     MOVFF 0x61, 0x13
004C  F013     NOP
004E  C062     MOVFF 0x62, 0x14
0050  F014     NOP
0052  A2F2     BTFSS INTCON, 1, ACCESS
0054  D069     BRA 0x128
0056  92F2     BCF INTCON, 1, ACCESS
0058  BA8A     BTFSC LATB, 5, ACCESS
005A  D003     BRA 0x62
005C  6A01     CLRF __pcstackCOMRAM, ACCESS
005E  2A01     INCF __pcstackCOMRAM, F, ACCESS
0060  D001     BRA 0x64
0062  6A01     CLRF __pcstackCOMRAM, ACCESS
0064  3A01     SWAPF __pcstackCOMRAM, F, ACCESS
0066  4601     RLNCF __pcstackCOMRAM, F, ACCESS
0068  508A     MOVF LATB, W, ACCESS
006A  1801     XORWF __pcstackCOMRAM, W, ACCESS
006C  0BDF     ANDLW 0xDF
006E  1801     XORWF __pcstackCOMRAM, W, ACCESS
0070  6E8A     MOVWF LATB, ACCESS
0072  045E     DECF l_state, W, ACCESS
0074  A4D8     BTFSS STATUS, 2, ACCESS
0076  D004     BRA 0x80
0078  0E0B     MOVLW 0xB
007A  2658     ADDWF l_full, F, ACCESS
007C  0E00     MOVLW 0x0
007E  2259     ADDWFC 0x59, F, ACCESS
0080  0E00     MOVLW 0x0
0082  6E5E     MOVWF l_state, ACCESS
0084  A42F     BTFSS 0x2F, 2, ACCESS
0086  D003     BRA 0x8E
0088  6A01     CLRF __pcstackCOMRAM, ACCESS
008A  2A01     INCF __pcstackCOMRAM, F, ACCESS
008C  D001     BRA 0x90
008E  6A01     CLRF __pcstackCOMRAM, ACCESS
0090  5001     MOVF __pcstackCOMRAM, W, ACCESS
0092  0D06     MULLW 0x6
0094  0E4C     MOVLW 0x4C
0096  24F3     ADDWF PROD, W, ACCESS
0098  6E32     MOVWF L_ptr, ACCESS
009A  0E00     MOVLW 0x0
009C  20F4     ADDWFC PRODH, W, ACCESS
009E  6E33     MOVWF 0x33, ACCESS
00A0  D036     BRA 0x10E
00A2  0E1F     MOVLW 0x1F
00A4  C032     MOVFF L_ptr, FSR2
00A6  FFD9     NOP
00A8  C033     MOVFF 0x33, FSR2H
00AA  FFDA     NOP
00AC  5EDE     SUBWF POSTINC2, F, ACCESS
00AE  0E00     MOVLW 0x0
00B0  5ADD     SUBWFB POSTDEC2, F, ACCESS
00B2  C032     MOVFF L_ptr, FSR2
00B4  FFD9     NOP
00B6  C033     MOVFF 0x33, FSR2H
00B8  FFDA     NOP
00BA  5058     MOVF l_full, W, ACCESS
00BC  5CDE     SUBWF POSTINC2, W, ACCESS
00BE  5059     MOVF 0x59, W, ACCESS
00C0  58DE     SUBWFB POSTINC2, W, ACCESS
00C2  B0D8     BTFSC STATUS, 0, ACCESS
00C4  D030     BRA 0x126
00C6  C032     MOVFF L_ptr, FSR2
00C8  FFD9     NOP
00CA  C033     MOVFF 0x33, FSR2H
00CC  FFDA     NOP
00CE  0EFA     MOVLW 0xFA
00D0  6EDE     MOVWF POSTINC2, ACCESS
00D2  0EFF     MOVLW 0xFF
00D4  6EDD     MOVWF POSTDEC2, ACCESS
00D6  D027     BRA 0x126
00D8  0E43     MOVLW 0x43
00DA  C032     MOVFF L_ptr, FSR2
00DC  FFD9     NOP
00DE  C033     MOVFF 0x33, FSR2H
00E0  FFDA     NOP
00E2  26DE     ADDWF POSTINC2, F, ACCESS
00E4  0E00     MOVLW 0x0
00E6  22DD     ADDWFC POSTDEC2, F, ACCESS
00E8  C032     MOVFF L_ptr, FSR2
00EA  FFD9     NOP
00EC  C033     MOVFF 0x33, FSR2H
00EE  FFDA     NOP
00F0  5058     MOVF l_full, W, ACCESS
00F2  5CDE     SUBWF POSTINC2, W, ACCESS
00F4  5059     MOVF 0x59, W, ACCESS
00F6  58DE     SUBWFB POSTINC2, W, ACCESS
00F8  B0D8     BTFSC STATUS, 0, ACCESS
00FA  D015     BRA 0x126
00FC  C032     MOVFF L_ptr, FSR2
00FE  FFD9     NOP
0100  C033     MOVFF 0x33, FSR2H
0102  FFDA     NOP
0104  C058     MOVFF l_full, POSTINC2
0106  FFDE     NOP
0108  C059     MOVFF 0x59, POSTDEC2
010A  FFDD     NOP
010C  D00C     BRA 0x126
010E  A42F     BTFSS 0x2F, 2, ACCESS
0110  D002     BRA 0x116
0112  0E01     MOVLW 0x1
0114  D001     BRA 0x118
0116  0E00     MOVLW 0x0
0118  0A00     XORLW 0x0
011A  B4D8     BTFSC STATUS, 2, ACCESS
011C  D7C2     BRA 0xA2
011E  0A01     XORLW 0x1
0120  B4D8     BTFSC STATUS, 2, ACCESS
0122  D7DA     BRA 0xD8
0124  D7BE     BRA 0xA2
0126  742F     BTG 0x2F, 2, ACCESS
0128  B09E     BTFSC PIR1, 0, ACCESS
012A  D003     BRA 0x132
012C  505E     MOVF l_state, W, ACCESS
012E  A4D8     BTFSS STATUS, 2, ACCESS
0130  D044     BRA 0x1BA
0132  909E     BCF PIR1, 0, ACCESS
0134  505E     MOVF l_state, W, ACCESS
0136  0D02     MULLW 0x2
0138  50F3     MOVF PROD, W, ACCESS
013A  2432     ADDWF L_ptr, W, ACCESS
013C  6ED9     MOVWF FSR2, ACCESS
013E  50F4     MOVF PRODH, W, ACCESS
0140  2033     ADDWFC 0x33, W, ACCESS
0142  6EDA     MOVWF FSR2H, ACCESS
0144  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
0146  F001     NOP
0148  CFDD     MOVFF POSTDEC2, 0x2
014A  F002     NOP
014C  C002     MOVFF 0x2, __pcstackCOMRAM
014E  F001     NOP
0150  6A02     CLRF 0x2, ACCESS
0152  5001     MOVF __pcstackCOMRAM, W, ACCESS
0154  6ECF     MOVWF TMR1H, ACCESS
0156  505E     MOVF l_state, W, ACCESS
0158  0D02     MULLW 0x2
015A  50F3     MOVF PROD, W, ACCESS
015C  2432     ADDWF L_ptr, W, ACCESS
015E  6ED9     MOVWF FSR2, ACCESS
0160  50F4     MOVF PRODH, W, ACCESS
0162  2033     ADDWFC 0x33, W, ACCESS
0164  6EDA     MOVWF FSR2H, ACCESS
0166  50DF     MOVF INDF2, W, ACCESS
0168  6ECE     MOVWF TMR1, ACCESS
016A  D01E     BRA 0x1A8
016C  9089     BCF LATA, 0, ACCESS
016E  9289     BCF LATA, 1, ACCESS
0170  9489     BCF LATA, 2, ACCESS
0172  0E01     MOVLW 0x1
0174  D013     BRA 0x19C
0176  8089     BSF LATA, 0, ACCESS
0178  D010     BRA 0x19A
017A  8289     BSF LATA, 1, ACCESS
017C  D00E     BRA 0x19A
017E  8489     BSF LATA, 2, ACCESS
0180  D00C     BRA 0x19A
0182  A42F     BTFSS 0x2F, 2, ACCESS
0184  D002     BRA 0x18A
0186  0E01     MOVLW 0x1
0188  D001     BRA 0x18C
018A  0E00     MOVLW 0x0
018C  0A00     XORLW 0x0
018E  B4D8     BTFSC STATUS, 2, ACCESS
0190  D7F2     BRA 0x176
0192  0A01     XORLW 0x1
0194  B4D8     BTFSC STATUS, 2, ACCESS
0196  D7F1     BRA 0x17A
0198  D7F2     BRA 0x17E
019A  0E02     MOVLW 0x2
019C  6E5E     MOVWF l_state, ACCESS
019E  D00D     BRA 0x1BA
01A0  9089     BCF LATA, 0, ACCESS
01A2  9289     BCF LATA, 1, ACCESS
01A4  9489     BCF LATA, 2, ACCESS
01A6  D009     BRA 0x1BA
01A8  505E     MOVF l_state, W, ACCESS
01AA  0A00     XORLW 0x0
01AC  B4D8     BTFSC STATUS, 2, ACCESS
01AE  D7DE     BRA 0x16C
01B0  0A01     XORLW 0x1
01B2  B4D8     BTFSC STATUS, 2, ACCESS
01B4  D7E6     BRA 0x182
01B6  0A03     XORLW 0x3
01B8  D7F3     BRA 0x1A0
01BA  AA9E     BTFSS PIR1, 5, ACCESS
01BC  D007     BRA 0x1CC
01BE  CFAE     MOVFF RCREG, 0x30
01C0  F030     NOP
01C2  A2AB     BTFSS RCSTA, 1, ACCESS
01C4  D002     BRA 0x1CA
01C6  98AB     BCF RCSTA, 4, ACCESS
01C8  88AB     BSF RCSTA, 4, ACCESS
01CA  822D     BSF V, 1, ACCESS
01CC  A4F2     BTFSS INTCON, 2, ACCESS
01CE  D012     BRA 0x1F4
01D0  94F2     BCF INTCON, 2, ACCESS
01D2  505D     MOVF 0x5D, W, ACCESS
01D4  6ED7     MOVWF TMR0H, ACCESS
01D6  C05C     MOVFF timer0_off, TMR0
01D8  FFD6     NOP
01DA  BE8A     BTFSC LATB, 7, ACCESS
01DC  D003     BRA 0x1E4
01DE  6A01     CLRF __pcstackCOMRAM, ACCESS
01E0  2A01     INCF __pcstackCOMRAM, F, ACCESS
01E2  D001     BRA 0x1E6
01E4  6A01     CLRF __pcstackCOMRAM, ACCESS
01E6  3201     RRCF __pcstackCOMRAM, F, ACCESS
01E8  3201     RRCF __pcstackCOMRAM, F, ACCESS
01EA  508A     MOVF LATB, W, ACCESS
01EC  1801     XORWF __pcstackCOMRAM, W, ACCESS
01EE  0B7F     ANDLW 0x7F
01F0  1801     XORWF __pcstackCOMRAM, W, ACCESS
01F2  6E8A     MOVWF LATB, ACCESS
01F4  C014     MOVFF 0x14, 0x62
01F6  F062     NOP
01F8  C013     MOVFF 0x13, 0x61
01FA  F061     NOP
01FC  C012     MOVFF 0x12, 0x60
01FE  F060     NOP
0200  C011     MOVFF 0x11, btemp
0202  F05F     NOP
0204  C010     MOVFF 0x10, TABLAT
0206  FFF5     NOP
0208  C00F     MOVFF 0xF, TBLPTRU
020A  FFF8     NOP
020C  C00E     MOVFF 0xE, TBLPTRH
020E  FFF7     NOP
0210  C00D     MOVFF 0xD, TBLPTR
0212  FFF6     NOP
0214  C00C     MOVFF 0xC, PRODH
0216  FFF4     NOP
0218  C00B     MOVFF 0xB, PROD
021A  FFF3     NOP
021C  C00A     MOVFF 0xA, FSR2H
021E  FFDA     NOP
0220  C009     MOVFF 0x9, FSR2
0222  FFD9     NOP
0224  C008     MOVFF 0x8, FSR1H
0226  FFE2     NOP
0228  C007     MOVFF 0x7, FSR1
022A  FFE1     NOP
022C  C006     MOVFF 0x6, FSR0H
022E  FFEA     NOP
0230  C005     MOVFF 0x5, FSR0
0232  FFE9     NOP
0234  C004     MOVFF 0x4, PCLATU
0236  FFFB     NOP
0238  C003     MOVFF 0x3, PCLATH
023A  FFFA     NOP
023C  925F     BCF btemp, 1, ACCESS
023E  0011     RETFIE 1
297:           
298:           void main(void)
299:           {
300:           	init_rmsmon();
05CE  EC8F     CALL 0x31E, 0
05D0  F001     NOP
301:           
302:           	/* Loop forever */
303:           	while (TRUE) { // busy work
05D6  D7FD     BRA 0x5D2
304:           		sw_work(); // run housekeeping
05D2  ECD0     CALL 0x3A0, 0
05D4  F001     NOP
05D6  D7FD     BRA 0x5D2
305:           	}
306:           }
